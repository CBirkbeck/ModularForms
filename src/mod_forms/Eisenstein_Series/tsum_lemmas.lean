import data.complex.exponential
import analysis.calculus.series
import analysis.calculus.parametric_interval_integral
import data.complex.basic

noncomputable theory

open topological_space set  metric filter function complex measure_theory

open_locale interval real nnreal ennreal topology big_operators nat classical



lemma embedding_coer : embedding (coe : ‚Ñù ‚Üí ‚ÑÇ) :=
begin
apply isometry.embedding,
apply isometry_of_real,
end

@[norm_cast] lemma tendsto_coe { Œ± : Type*} {f : filter Œ±} {m : Œ± ‚Üí ‚Ñù} {a : ‚Ñù} :
  tendsto (Œªa, (m a : ‚ÑÇ)) f (ùìù ‚Üëa) ‚Üî tendsto m f (ùìù a) :=
embedding_coer.tendsto_nhds_iff.symm


@[simp, norm_cast] lemma coe_finset_sum { Œ± : Type*} {s : finset Œ±} {f : Œ± ‚Üí ‚Ñù} :
  ‚Üë(‚àë a in s, f a) = (‚àë a in s, f a : ‚ÑÇ) :=
of_real.map_sum f s

@[norm_cast] protected lemma has_sum_coe { Œ± : Type*} {f : Œ± ‚Üí ‚Ñù} {r : ‚Ñù} :
  has_sum (Œªa, (f a : ‚ÑÇ)) ‚Üër ‚Üî has_sum f r :=
have (Œªs:finset Œ±, ‚àë a in s, ‚Üë(f a)) = (coe : ‚Ñù ‚Üí ‚ÑÇ) ‚àò (Œªs:finset Œ±, ‚àë a in s, f a),
  from funext $ assume s, coe_finset_sum.symm,
by unfold has_sum; rw [this, tendsto_coe]

protected lemma tsum_coe_eq { Œ± : Type*} {f : Œ± ‚Üí ‚Ñù} {r : ‚Ñù} (h : has_sum f r) : ‚àë'a, (f a : ‚ÑÇ) = r :=
(has_sum_coe.2 h).tsum_eq

protected lemma coe_tsum { Œ± : Type*} {f : Œ± ‚Üí ‚Ñù} : summable f ‚Üí ‚Üë(tsum f) = ‚àë'a, (f a : ‚ÑÇ)
| ‚ü®r, hr‚ü© := by rw [hr.tsum_eq, tsum_coe_eq hr]


lemma coe_summable { Œ± : Type*} (f : Œ± ‚Üí ‚Ñù) : summable ((coe : ‚Ñù ‚Üí ‚ÑÇ) ‚àò f) ‚Üî summable f :=
begin
  apply summable.map_iff_of_left_inverse complex.of_real complex.re_add_group_hom,
  exact complex.continuous_of_real,
  exact complex.continuous_re,
  intro, refl,
end

lemma tsum_coe { Œ± : Type*} (f : Œ± ‚Üí ‚Ñù) :   ‚àë' i, (f i : ‚ÑÇ) = ((‚àë' i, f i) : ‚Ñù) :=
begin
by_cases hf : summable f,
apply (coe_tsum hf).symm,
have := tsum_eq_zero_of_not_summable hf,
rw this,
simp,
have h2:= coe_summable f,
apply tsum_eq_zero_of_not_summable,
rw h2,
apply hf,
end

lemma nat_pos_tsum2 (f : ‚Ñï ‚Üí ‚ÑÇ) (hf : f 0 = 0 ) : summable (Œª (x : ‚Ñï+), f x) ‚Üî  summable f :=
begin
rw function.injective.summable_iff,
simp,
exact pnat.coe_injective,
intros x hx,
simp at hx,
rw hx,
exact hf,

end

lemma has_sum_pnat' (f : ‚Ñï ‚Üí ‚ÑÇ) (hf2: summable f) : has_sum (Œª n:‚Ñï, f(n + 1)) (‚àë' (n : ‚Ñï+), f n) :=
begin
  have:= (_root_.equiv.pnat_equiv_nat).has_sum_iff,
  simp_rw equiv.pnat_equiv_nat at *,
  simp at *,
  rw ‚Üêthis,
  have hf3 : summable ((Œª (n : ‚Ñï), f (n + 1)) ‚àò pnat.nat_pred), by {
    have hs : summable (Œª (n : ‚Ñï+), f n), by  {apply (hf2).subtype},
    apply summable.congr hs,
    intro b, simp,},
  rw (summable.has_sum_iff hf3),
  congr,
  funext,
  simp,
end

lemma nat_pos_tsum2' {Œ± : Type*}[topological_space Œ±] [add_comm_monoid Œ±] (f : ‚Ñï ‚Üí Œ±) :
summable (Œª (x : ‚Ñï+), f x) ‚Üî summable (Œª x : ‚Ñï, (f (x + 1))):=
begin
rw ‚Üêequiv.summable_iff (_root_.equiv.pnat_equiv_nat),
split,
intro hf,
apply summable.congr hf,
intro b,
simp,
intro hf,
apply summable.congr hf,
intro b,
simp,
end



lemma tsum_pnat (f : ‚Ñï ‚Üí ‚ÑÇ) (hf : f 0 = 0) : ‚àë' (n : ‚Ñï+), f n = ‚àë' n, f n :=
begin
by_cases hf2: summable f,
rw tsum_eq_zero_add,
rw hf,
simp,
have hpos : has_sum (Œª n:‚Ñï, f(n + 1)) (‚àë' (n : ‚Ñï+), f n), by {
  have:= (_root_.equiv.pnat_equiv_nat).has_sum_iff,
  simp_rw equiv.pnat_equiv_nat at *,
  simp at *,
  rw ‚Üêthis,
  have hf3 : summable ((Œª (n : ‚Ñï), f (n + 1)) ‚àò pnat.nat_pred), by {
    have hs : summable (Œª (n : ‚Ñï+), f n), by  {apply (hf2).subtype},
    apply summable.congr hs,
    intro b, simp,},
  rw (summable.has_sum_iff hf3),
  congr,
  funext,
  simp,},
apply symm,
apply hpos.tsum_eq,
apply hf2,
have h1 := tsum_eq_zero_of_not_summable hf2,
rw ‚Üê(nat_pos_tsum2 f hf) at hf2,
have h2:= tsum_eq_zero_of_not_summable hf2,
simp [h1,h2],
end

lemma tsum_pnat' (f : ‚Ñï ‚Üí ‚ÑÇ) : ‚àë' (n : ‚Ñï+), f n = ‚àë' n, f (n + 1) :=
begin
by_cases hf2: summable (Œª (n : ‚Ñï+), f n),
have hpos : has_sum (Œª n:‚Ñï, f(n + 1)) (‚àë' (n : ‚Ñï+), f n), by {
  have:= (_root_.equiv.pnat_equiv_nat).has_sum_iff,
  simp_rw equiv.pnat_equiv_nat at *,
  simp at *,
  rw ‚Üêthis,
  have hf3 : summable ((Œª (n : ‚Ñï), f (n + 1)) ‚àò pnat.nat_pred), by {
    apply summable.congr hf2,
    intro b, simp,},
  rw (summable.has_sum_iff hf3),
  congr,
  funext,
  simp,},
apply symm,
apply hpos.tsum_eq,
have h1 := tsum_eq_zero_of_not_summable hf2,
rw nat_pos_tsum2' at hf2,
have h2:= tsum_eq_zero_of_not_summable hf2,
simp [h1,h2],
end


lemma prod_sum (f : ‚Ñ§ √ó ‚Ñ§ ‚Üí ‚ÑÇ) (hf : summable f) : summable (Œª a, ‚àë' b, f ‚ü®a,b‚ü© ) :=
begin
have := equiv.summable_iff (equiv.sigma_equiv_prod ‚Ñ§ ‚Ñ§) ,
rw ‚Üêthis at hf,
have H:= summable.sigma hf,
simp at H,
apply summable.congr H,
intro b,
simp,
end

def mapdiv (n : ‚Ñï+) : (nat.divisors_antidiagonal n) ‚Üí ‚Ñï+ √ó ‚Ñï+ :=
begin
intro x,
have h1 := x.1.1,
have h11:= nat.fst_mem_divisors_of_mem_antidiagonal x.2,
have h111:= nat.pos_of_mem_divisors h11,
have h2 := x.1.2,
have h22:= nat.snd_mem_divisors_of_mem_antidiagonal x.2,
have h222:= nat.pos_of_mem_divisors h22,
set n1 : ‚Ñï+ := ‚ü®x.1.1, h111‚ü©,
set n2 : ‚Ñï+ := ‚ü®x.1.2, h222‚ü©,
use ‚ü®n1,n2‚ü©,
end

variable (f : Œ£ (n : ‚Ñï+), nat.divisors_antidiagonal n)


def sigma_antidiagonal_equiv_prod : (Œ£ (n : ‚Ñï+), nat.divisors_antidiagonal n) ‚âÉ ‚Ñï+ √ó ‚Ñï+ :=
{ to_fun := Œª x, mapdiv x.1 x.2,
  inv_fun := Œª x, ‚ü®‚ü®x.1.1 * x.2.1, by {apply mul_pos x.1.2 x.2.2} ‚ü©, ‚ü®x.1,x.2‚ü©,
    by {rw nat.mem_divisors_antidiagonal, simp, }‚ü©,
  left_inv :=
    begin
      rintros ‚ü®n, ‚ü®k, l‚ü©, h‚ü©,
      rw nat.mem_divisors_antidiagonal at h,
      simp_rw mapdiv,
      simp only [h, pnat.mk_coe, eq_self_iff_true, subtype.coe_eta, true_and],
      cases h, cases n, dsimp at *, induction h_left, refl,
    end,
  right_inv := by {
    rintros ‚ü®n, ‚ü®k, l‚ü©, h‚ü©,
    simp_rw mapdiv,
    exfalso,
    simp only [not_lt_zero'] at h,
    exact h,
    simp_rw mapdiv,
    simp only [eq_self_iff_true, subtype.coe_eta],}, }


lemma summable_mul_prod_iff_summable_mul_sigma_antidiagonall {f  : ‚Ñï+ √ó ‚Ñï+ ‚Üí ‚ÑÇ} :
  summable (Œª x : ‚Ñï+ √ó ‚Ñï+, f x ) ‚Üî
  summable (Œª x : (Œ£ (n : ‚Ñï+), nat.divisors_antidiagonal n), f ‚ü®(mapdiv x.1 x.2).1,  (mapdiv x.1 x.2).2‚ü©) :=
begin
simp_rw mapdiv,
apply  sigma_antidiagonal_equiv_prod.summable_iff.symm,
end

lemma nat_pos_tsum (f : ‚Ñï ‚Üí ‚Ñù) (hf : f 0 = 0 ) : summable (Œª (x : ‚Ñï+), f x) ‚Üî   summable f :=
begin
rw function.injective.summable_iff,
simp,
exact pnat.coe_injective,
intros x hx,
simp at hx,
rw hx,
exact hf,

end

lemma nat_pos_tsum' (Œæ : ‚ÑÇ) :  summable (Œª n : ‚Ñï, Œæ ^ n) ‚Üí summable (Œª n : ‚Ñï+, Œæ ^ (n : ‚Ñï)) :=
begin
intro h,
apply h.subtype,
end

lemma sumaux (f : ‚Ñï √ó ‚Ñï ‚Üí ‚ÑÇ) (e : ‚Ñï+) : ‚àë (x : nat.divisors_antidiagonal e), f x =
  ‚àë (x : ‚Ñï √ó ‚Ñï) in nat.divisors_antidiagonal e, f x :=
begin
simp only [finset.univ_eq_attach],
apply finset.sum_finset_coe,
end


lemma int_nat_sum (f : ‚Ñ§ ‚Üí ‚ÑÇ) : summable f ‚Üí  summable (Œª (x : ‚Ñï), f x)   :=
begin
have : is_compl (set.range (coe : ‚Ñï ‚Üí ‚Ñ§)) (set.range int.neg_succ_of_nat),
  { split,
    { rw disjoint_iff_inf_le,
      rintros _ ‚ü®‚ü®i, rfl‚ü©, ‚ü®j, ‚ü®‚ü©‚ü©‚ü© },
    { rw codisjoint_iff_le_sup,
      rintros (i | j) h,
      exacts [or.inl ‚ü®_, rfl‚ü©, or.inr ‚ü®_, rfl‚ü©] } },
  intro h,
  rw ‚Üê@summable_subtype_and_compl _ _ _ _ _ f _ (set.range (coe : ‚Ñï ‚Üí ‚Ñ§))   at h,
  cases h,
  rw ‚Üê(equiv.of_injective (coe : ‚Ñï ‚Üí ‚Ñ§) nat.cast_injective).symm.summable_iff ,
  apply summable.congr h_left,
  intro b,
  funext,
  simp_rw equiv.apply_of_injective_symm,
  simp,
  apply congr_arg,
  cases b, cases h_right, cases h_left, cases b_property, induction b_property_h, dsimp at *,
  simp at *,
end

lemma sum_int_even (f : ‚Ñ§ ‚Üí ‚ÑÇ) (hf : ‚àÄ (n : ‚Ñ§), f n = f (-n)) (hf2 : summable f) :
 ‚àë' n, f n = f 0 + 2 * ‚àë' (n : ‚Ñï+), f n :=
begin
have hpos : has_sum (Œª n:‚Ñï, f(n + 1)) (‚àë' (n : ‚Ñï+), f n), by {
  have:= (_root_.equiv.pnat_equiv_nat).has_sum_iff,
  simp_rw equiv.pnat_equiv_nat at *,
  simp at *,
  rw ‚Üêthis,
  have hf3 : summable ((Œª (n : ‚Ñï), f (‚Üën + 1)) ‚àò pnat.nat_pred), by {
    have hs : summable (Œª (n : ‚Ñï+), f n), by  {apply (int_nat_sum f hf2).subtype},
    apply summable.congr hs,
    intro b, simp, congr, simp },
  rw (summable.has_sum_iff hf3),
  congr,
  funext,
  simp,
  congr,
  norm_cast,
  simp,},
have hneg : has_sum (Œª (n : ‚Ñï), f (-n.succ)) (‚àë' (n : ‚Ñï+), f n), by {
  have h1 : (Œª (n : ‚Ñï), f (-‚Üë(n.succ))) = (Œª (n : ‚Ñï), f (‚Üë(n.succ))) , by {
    funext,
    apply hf,
  },
  rw h1,
  convert hpos,},

have:=(has_sum.pos_add_zero_add_neg hpos hneg).tsum_eq,
rw this,
ring,
end

def neg_equiv : ‚Ñ§ ‚âÉ ‚Ñ§ :=
{to_fun := Œª n, -n,
 inv_fun := Œª n, -n,
 left_inv := by {apply neg_neg,},
 right_inv:= by {apply neg_neg,},
}

def succ_equiv : ‚Ñ§ ‚âÉ ‚Ñ§ :=
{to_fun := Œª n, n.succ,
 inv_fun := Œª n, n.pred,
 left_inv := by {apply int.pred_succ,},
 right_inv:= by {apply int.succ_pred,},
}

lemma summable_neg (f : ‚Ñ§ ‚Üí ‚ÑÇ) (hf : summable f) : summable (Œª d, f (-d)) :=
begin
have h : (Œª d, f (-d)) = (Œª d, f d) ‚àò neg_equiv.to_fun, by {funext,
  simp,
  refl,},
rw h,
have := neg_equiv.summable_iff.mpr hf,
apply this,
end

lemma int_sum_neg (f : ‚Ñ§ ‚Üí ‚ÑÇ) (hf : summable f) : ‚àë' (d : ‚Ñ§), f d = ‚àë' d, f (-d) :=
begin
have h : (Œª d, f (-d)) = (Œª d, f d) ‚àò neg_equiv.to_fun, by {funext,
  simp,
  refl,},
rw h,
apply symm,
apply neg_equiv.tsum_eq,
exact t2_5_space.t2_space,
end

lemma int_tsum_pnat (f : ‚Ñ§ ‚Üí ‚ÑÇ) (hf2 : summable f) :
  ‚àë' n, f n = f 0 + (‚àë' (n : ‚Ñï+), f n) + ‚àë' (m : ‚Ñï+), f (-m) :=
begin
have hpos : has_sum (Œª n:‚Ñï, f(n + 1)) (‚àë' (n : ‚Ñï+), f n), by {
  have:= (_root_.equiv.pnat_equiv_nat).has_sum_iff,
  simp_rw equiv.pnat_equiv_nat at *,
  simp at *,
  rw ‚Üêthis,
  have hf3 : summable ((Œª (n : ‚Ñï), f (‚Üën + 1)) ‚àò pnat.nat_pred), by {
    have hs : summable (Œª (n : ‚Ñï+), f n), by  {apply (int_nat_sum f hf2).subtype},
    apply summable.congr hs,
    intro b, simp, congr, simp },
  rw (summable.has_sum_iff hf3),
  congr,
  funext,
  simp,
  congr,
  norm_cast,
  simp,},
have hneg : has_sum (Œª (n : ‚Ñï), f (-n.succ)) (‚àë' (n : ‚Ñï+), f (-n)), by {
  have:= (_root_.equiv.pnat_equiv_nat).has_sum_iff,
  simp_rw equiv.pnat_equiv_nat at *,
  rw ‚Üêthis,
   rw (summable.has_sum_iff _),
   congr,
   funext,
   simp,
   congr,
   simp_rw pnat.nat_pred,
   simp,
   ring,
   exact t2_5_space.t2_space,
   rw equiv.summable_iff,
   have H : summable (Œª (d : ‚Ñ§), f (d.pred)), by {
    have := succ_equiv.symm.summable_iff.2 hf2,
    apply this},
   have H2:= summable_neg _ H,

   have := int_nat_sum _ H2,
   apply summable.congr this,
   intro b,
   simp,
   congr,
   simp_rw int.pred,
   ring,
   exact add_comm_group.to_add_comm_monoid ‚ÑÇ,
   exact uniform_space.to_topological_space,
   },
have:=(has_sum.pos_add_zero_add_neg hpos hneg).tsum_eq,
rw this,
ring_nf,

end


lemma has_deriv_at_tsum_fun {Œ± : Type*} [ne_bot (at_top : filter (finset Œ±))] (f : Œ± ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ)
  {s : set ‚ÑÇ} (hs : is_open s) (x : ‚ÑÇ) (hx  : x ‚àà s)
  (hf : ‚àÄ (y : ‚ÑÇ), y ‚àà s ‚Üí summable (Œª (n : Œ±), f n y ))
  (hu : ‚àÄ K ‚äÜ s, is_compact K ‚Üí
  (‚àÉ (u : Œ±   ‚Üí ‚Ñù), ( summable u ‚àß ‚àÄ (n : Œ± ) (k : K), (complex.abs (deriv (f n) k)) ‚â§ u n )))
  (hf2 : ‚àÄ (n : Œ± ) (r : s), differentiable_at ‚ÑÇ (f n) r ):
  has_deriv_at (Œª z, ‚àë' (n : Œ± ), f n z)
  (‚àë' (n : Œ± ), (deriv (Œª z, f n z) x) ) x:=
begin
 have A : ‚àÄ (x : ‚ÑÇ), x ‚àà s‚Üí  tendsto (Œª (t : finset Œ± ), ‚àë n in t, (Œª z,f n z) x)
    at_top (ùìù (‚àë' (n : Œ±), (Œª z, f n z) x)),
  { intros y hy,
    apply summable.has_sum,
    simp,
    apply hf y hy},
 apply has_deriv_at_of_tendsto_locally_uniformly_on hs _ _ A,
 exact hx,
 use (Œª n : finset Œ±, Œª  a, (‚àë i in n, (deriv (Œª z, f i z) a) )),
 rw tendsto_locally_uniformly_on_iff_forall_is_compact hs,
 intros K hK1 hK2,
 have HU := hu K hK1 hK2,
  obtain ‚ü®u, hu1,hu2‚ü©:= HU,
 apply tendsto_uniformly_on_tsum hu1,
 intros n x hx,
simp,
apply hu2 n ‚ü®x, hx‚ü©,
 exact complete_of_proper,
 apply eventually_of_forall,
 intros t r hr,
 apply has_deriv_at.sum,
 intros q w,
 rw has_deriv_at_deriv_iff,
 simp,
 apply hf2 q ‚ü®r, hr‚ü©,
end

lemma has_deriv_within_at_tsum_fun {Œ± : Type*} [ne_bot (at_top : filter (finset Œ±))]
  (f : Œ±  ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ) {s : set ‚ÑÇ} (hs : is_open s) (x : ‚ÑÇ) (hx  : x ‚àà s)
   (hf : ‚àÄ (y : ‚ÑÇ), y ‚àà s ‚Üí summable (Œª (n : Œ±), f n y ))
   (hu : ‚àÄ K ‚äÜ s, is_compact K ‚Üí
    (‚àÉ (u : Œ± ‚Üí ‚Ñù), ( summable u ‚àß ‚àÄ (n : Œ± ) (k : K), (complex.abs (deriv (f n) k)) ‚â§ u n )))
    (hf2 : ‚àÄ (n : Œ± ) (r : s), differentiable_at ‚ÑÇ (f n) r ):
  has_deriv_within_at (Œª z, ‚àë' (n : Œ± ), f n z)
    (‚àë' (n : Œ± ), (deriv (Œª z, f n z) x) ) s x:=
begin
exact (has_deriv_at_tsum_fun f hs x hx hf hu hf2).has_deriv_within_at,
end

lemma has_deriv_within_at_tsum_fun' {Œ± : Type*} [ne_bot (at_top : filter (finset Œ±))]
   (f : Œ±  ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ) {s : set ‚ÑÇ} (hs : is_open s) (x : ‚ÑÇ)
  (hx  : x ‚àà s)
  (hf : ‚àÄ (y : ‚ÑÇ), y ‚àà s ‚Üí summable (Œª (n : Œ± ), f n y ))
  (hu : ‚àÄ K ‚äÜ s, is_compact K ‚Üí
  (‚àÉ (u : Œ±  ‚Üí ‚Ñù), ( summable u ‚àß ‚àÄ (n : Œ± ) (k : K), (complex.abs (deriv (f n) k)) ‚â§ u n )))
  (hf2 : ‚àÄ (n : Œ± ) (r : s), differentiable_at ‚ÑÇ (f n) r ):
  has_deriv_within_at (Œª z, ‚àë' (n : Œ± ), f n z)
  (‚àë' (n : Œ± ), (deriv_within (Œª z, f n z) s x) ) s x:=
begin
have := has_deriv_within_at_tsum_fun f hs x hx hf hu hf2,
convert this,
simp,
ext1 n,
apply differentiable_at.deriv_within ,
apply hf2 n ‚ü®x,hx‚ü©,
apply (is_open.unique_diff_within_at hs hx),
end

lemma deriv_tsum_fun'  {Œ± : Type*} [ne_bot (at_top : filter (finset Œ±))]
   (f : Œ±  ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ) {s : set ‚ÑÇ} (hs : is_open s) (x : ‚ÑÇ) (hx  : x ‚àà s)
   (hf : ‚àÄ (y : ‚ÑÇ), y ‚àà s ‚Üí summable (Œª (n : Œ± ), f n y ))
   (hu : ‚àÄ K ‚äÜ s, is_compact K ‚Üí
    (‚àÉ (u : Œ±  ‚Üí ‚Ñù), ( summable u ‚àß ‚àÄ (n : Œ± ) (k : K), (complex.abs (deriv (f n) k)) ‚â§ u n )))
    (hf2 : ‚àÄ (n : Œ± ) (r : s), differentiable_at ‚ÑÇ (f n) r ):
  deriv_within (Œª z, ‚àë' (n : Œ±  ), f n z) s x =
    (‚àë' (n : Œ± ), (deriv_within (Œª z, f n z) s x) ):=
begin
apply has_deriv_within_at.deriv_within (has_deriv_within_at_tsum_fun' f hs x hx hf hu hf2)
 (is_open.unique_diff_within_at hs hx),
end
