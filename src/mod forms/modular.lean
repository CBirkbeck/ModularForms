import analysis.complex.automorphisms_half_plane
import analysis.complex.basic
import data.matrix.notation
import data.int.basic
import data.int.parity
import data.nat.gcd
import algebra.ordered_ring
import ring_theory.int.basic
import data.real.sqrt
import linear_algebra.affine_space.affine_subspace

open complex
open matrix
open matrix.special_linear_group
noncomputable theory


local notation `|` x `|` := _root_.abs x
local notation `SL(` n `,` R `)`:= special_linear_group (fin n) R

-- special linear group over ‚Ñ§

/-- The action of `SL(2, ‚Ñ§)` on the upper half-plane, as a restriction of the `SL(2, ‚Ñù)`-action. -/
instance SL2Z_action : mul_action SL(2, ‚Ñ§) H :=
mul_action.comp_hom H (SL_n_insertion (int.cast_ring_hom ‚Ñù))

@[simp]
lemma smul_def_int (g : SL(2,‚Ñ§)) (z : H) : ‚Üë(g ‚Ä¢ z) = smul_aux g z :=
begin
  refl,
end

lemma smul_neg_SL2_int (g : SL(2,‚Ñ§)) (z : H) : -g ‚Ä¢ z = g ‚Ä¢ z :=
begin
  rw subtype.ext_iff,
  simp only [smul_def_int, smul_aux_def, top, bottom],
  rw ‚Üê neg_div_neg_eq,
  congr' 1; simp; ring,
end


@[simp]
lemma bottom_def {g : SL(2,‚Ñ§)} {z : ‚ÑÇ} : bottom g z = g.1 1 0 * z + g.1 1 1 := by simp

@[simp]
lemma top_def {g : SL(2,‚Ñ§)} {z : ‚ÑÇ} : top g z = g.1 0 0 * z + g.1 0 1 := by simp



lemma im_smul_SL' (g : SL(2, ‚Ñ§)) (z : H) :
(g ‚Ä¢ z).val.im = z.val.im / (complex.norm_sq (g.1 1 0 * z + g.1 1 1)) :=
by simpa using im_smul_SL g z

lemma im_smul_SL'' (g : SL(2, ‚Ñ§)) (z : H) :
(g ‚Ä¢ z).val.im = z.val.im / (complex.norm_sq (bottom g z)) :=
im_smul_mat_complex


@[simp]
lemma smul_sound {g : SL(2,‚Ñ§)} {z : H} : ((g:SL(2,‚Ñù)) ‚Ä¢ z).1 = smul_aux g z :=
rfl

-- T and S

def T : SL(2,‚Ñ§) := { val := ![![1, 1], ![0, 1]], property := by simp [det2] }

def S : SL(2,‚Ñ§) := { val := ![![0, -1], ![1, 0]], property := by simp [det2] }

example : T‚Åª¬π * T = 1 := inv_mul_self T

example { R : SL(2,‚Ñ§) } : R * T = 1 ‚Üí R = T‚Åª¬π := eq_inv_of_mul_eq_one

example { R : SL(2,‚Ñ§) } : T * R = 1 ‚Üí T‚Åª¬π = R := inv_eq_of_mul_eq_one

example { x y : SL(2,‚Ñ§)} (h : x.1 = y.1) : x = y := subtype.eq h

@[simp]
lemma mat_congr_SL { x y : SL(2,‚Ñ§) } : x = y ‚Üî x.val = y.val := subtype.ext_iff_val

@[simp]
lemma mat_ext_iff  {F : Type*} [comm_ring F] (x y : matrix (fin 2) (fin 2) F) :
  x = y ‚Üî x 0 0 = y 0 0 ‚àß x 0 1 = y 0 1 ‚àß x 1 0 = y 1 0 ‚àß x 1 1 = y 1 1 :=
begin
  rw ‚Üêmatrix.ext_iff,
  split,
  {
    intro h,
    rw h,
    tauto },
  {
    rintros ‚ü®h1, h2, h3, h4‚ü© i j,
    fin_cases i; fin_cases j; assumption,
  }
end

@[simp]
lemma mat_one {F : Type*} [comm_ring F] : (![![1,0], ![0,1]] : matrix (fin 2) (fin 2) F)
  = (1 : matrix (fin 2) (fin 2) F) := by {simp}


lemma T_inv : T‚Åª¬π = { val := ![![1, -1], ![0, 1]], property := by simp [det2] } :=
begin
  suffices : T * { val := ![![1, -1], ![0, 1]], property := by simp [det2] } = 1,
  { exact inv_eq_of_mul_eq_one this},
  simp [T],
end

lemma T_n_def {n : ‚Ñ§} :  T^(-n) = (T‚Åª¬π)^n := by {simp [inv_gpow, gpow_neg]}

lemma T_pow_‚Ñï {n : ‚Ñï} : T ^ n = { val := ![![1, n], ![0, 1]], property := by simp [det2] } :=
begin
  induction n with n hn,
  { simp },
  { rw [pow_succ', hn, T],
    simp [add_comm] }
end

lemma T_inv_pow_‚Ñï {n : ‚Ñï} : (T‚Åª¬π)^n = { val := ![![1, -n], ![0, 1]], property := by simp [det2] } :=
begin
  induction n with n hn,
  simp,
  have : (T‚Åª¬π) ^ n.succ = ((T‚Åª¬π)^n)* (T‚Åª¬π),
  {
    exact pow_succ' (T‚Åª¬π) n,
  },
  rw this,
  rw hn,
  rw T_inv,
  simp,
end


lemma T_pow {n : ‚Ñ§} : T^n = { val := ![![1, n], ![0, 1]], property := by simp [det2] } :=
begin
  by_cases n_ge_0 : 0 ‚â§ n,
  lift n to ‚Ñï with n_ge_0,
  refine T_pow_‚Ñï,
  exact n_ge_0,
  have : T ^ n = T ^ (- (-n)) := by simp,
  rw this,
  rw T_n_def,
  generalize' hk : -n=k,
  have k_ge_0 : 0 ‚â§ k,
  {
    rw ‚Üê hk,
    linarith,
  },
  have : n = -k,
  {
    rw ‚Üê hk,
    ring,
  },
  rw this,
  lift k to ‚Ñï using k_ge_0,
  rw gpow_coe_nat,
  norm_cast,
  rw T_inv_pow_‚Ñï,
end

lemma T_action {z : H} : (T ‚Ä¢ z).1 = z + 1 :=
begin
  convert @smul_sound T z,
  simp only [smul_aux_def, top, bottom, T, has_coe_SL_apply, subtype.coe_mk, map_cons],
  simp [special_linear_group.cons_apply_zero, special_linear_group.cons_apply_one],
end


lemma Tn_action {z : H} {n : ‚Ñ§} : (T^n ‚Ä¢ z).1 = z + n :=
begin
  have := @smul_sound (T^n) z,
  convert this,
  rw smul_aux,
  rw T_pow,
  rw top,
  rw bottom,
  simp,
end

lemma S_action (z : H) : (S ‚Ä¢ z).1 = -z‚Åª¬π :=
begin
  convert @smul_sound S z,
  simp only [smul_aux_def, top, bottom, S, has_coe_SL_apply, subtype.coe_mk, map_cons],
  simp [special_linear_group.cons_apply_zero, special_linear_group.cons_apply_one],
  ring,
end

def fundamental_domain : set H :=
{ z | 1 < (complex.norm_sq z) ‚àß |(complex.re z)| < (1 :‚Ñù)/ 2 }

notation `ùíü` := fundamental_domain

notation `ùíüc` := closure ùíü


lemma whatever : ùíüc = { z | 1 ‚â§ (complex.norm_sq z) ‚àß |(complex.re z)| ‚â§ (1 :‚Ñù)/ 2 } :=
begin

  sorry,
end

def coprime_ints := { cd :  ‚Ñ§ √ó ‚Ñ§ //  int.gcd cd.1 cd.2 = 1 }

instance : has_coe coprime_ints (‚Ñ§√ó‚Ñ§) := ‚ü® Œª x, x.val‚ü©

section finite_pairs

open filter continuous_linear_map

lemma tendsto_at_top_norm_sq : tendsto norm_sq (cocompact ‚ÑÇ) at_top :=
begin
  convert tendsto_norm_cocompact_at_top.at_top_mul_at_top tendsto_norm_cocompact_at_top,
  { simp [mul_self_abs] },
  { apply_instance },
  { apply_instance }
end

lemma tendsto_cocompact_of_left_inverse {Œ± Œ≤ : Type*} [topological_space Œ±] [topological_space Œ≤]
  {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ±} (hg : continuous g) (hfg : function.left_inverse g f) :
  tendsto f (cocompact Œ±) (cocompact Œ≤) :=
begin
  rw tendsto_iff_eventually,
  simp only [mem_cocompact, eventually_iff_exists_mem],
  rintros p ‚ü®v, hv, hvp‚ü©,
  rw mem_cocompact at hv,
  obtain ‚ü®t, ht, htv‚ü© := hv,
  refine ‚ü®(g '' t)·∂ú, _, _‚ü©,
  { rw mem_cocompact,
    refine ‚ü®g '' t, ht.image hg, rfl.subset‚ü© },
  intros x hx,
  have : f x ‚àà v,
  { apply htv,
    intros h,
    apply hx,
    have h‚ÇÅ : g (f x) ‚àà g '' t := ‚ü®f x, h, rfl‚ü©,
    convert h‚ÇÅ,
    calc x = id x : by simp
    ... = (g ‚àò f) x : by { congr, rw hfg } },
  exact hvp (f x) this
end

lemma finite_pairs (z : H) :
  filter.tendsto (Œª cd : coprime_ints , (((cd : ‚Ñ§√ó‚Ñ§).1 : ‚ÑÇ) * z + ((cd : ‚Ñ§ √ó ‚Ñ§).2 : ‚ÑÇ)).norm_sq)
  cofinite at_top :=
begin
  have h‚ÇÅ : tendsto (Œª c : ‚Ñù √ó ‚Ñù, ‚Üëc.1 * (z:‚ÑÇ) + c.2) (cocompact _) (cocompact _),
  { let g : ‚ÑÇ ‚ÜíL[‚Ñù] ‚Ñù√ó‚Ñù := im_clm.prod
      (im_clm.comp (((z:‚ÑÇ)‚Ä¢ conj_clm ))),
    apply tendsto_cocompact_of_left_inverse ((z:‚ÑÇ).im‚Åª¬π ‚Ä¢ g).continuous,
    rintros ‚ü®c‚ÇÅ, c‚ÇÇ‚ü©,
    have hz : 0 < (z:‚ÑÇ).im := z.2,
    have : (z:‚ÑÇ).im ‚â† 0 := hz.ne.symm,
    field_simp [g],
    ring },
  have h‚ÇÇ : tendsto (Œª c : ‚Ñ§ √ó ‚Ñ§, ((c.1 : ‚Ñù), (c.2 : ‚Ñù))) cofinite (cocompact _),
  { convert int.tendsto_coe_cofinite.prod_map_coprod int.tendsto_coe_cofinite;
    simp [coprod_cocompact, coprod_cofinite] },
  have h‚ÇÉ : tendsto (Œª c : ‚Ñ§ √ó ‚Ñ§, ((c.1 : ‚ÑÇ) * z + (c.2 : ‚ÑÇ)).norm_sq) cofinite at_top,
  { convert tendsto_at_top_norm_sq.comp (h‚ÇÅ.comp h‚ÇÇ),
    ext,
    simp },
  exact (h‚ÇÉ.comp (tendsto_embedding_cofinite (function.embedding.subtype _))),
end

end finite_pairs

---- delete later
lemma gcd_cast (a b : ‚Ñ§) : gcd a b = a.gcd b := (int.coe_gcd a b).symm

lemma gcd_eq_one_iff_coprime' (a b : ‚Ñ§) : gcd a b = 1 ‚Üî is_coprime a b :=
begin
  rw [‚Üêint.coe_gcd, ‚Üêint.coe_nat_one, int.coe_nat_inj', int.gcd_eq_one_iff_coprime],
end

lemma gcd_eq_one_iff_coprime'' (a b : ‚Ñ§) : (‚àÉ c d , a*d-b*c=1) ‚Üî is_coprime a b :=
begin
  split,
  { rintros ‚ü®c, d, h‚ü©,
    rw is_coprime,
    use d,
    use (-c),
    convert h using 1,
    ring },
  { rintros ‚ü®c, d, h‚ü©,
    use (-d),
    use c,
    convert h using 1,
    ring },
end

lemma gcd_eq_one_iff_coprime''' (a b : ‚Ñ§) : (‚àÉ c d , a*d-b*c=1) ‚Üî gcd a b = 1 :=
 iff.trans (gcd_eq_one_iff_coprime'' a b) (iff.symm (gcd_eq_one_iff_coprime' a b))


lemma bottom_row_coprime (g : SL(2, ‚Ñ§)) : int.gcd (g 1 0) (g 1 1) = 1 :=
begin
--- ALEX HOMEWORK
  have := @det2 _ _ g,
  have detIs := g.2,
  have e1 :  (‚àÉ (c d : ‚Ñ§), (g 1 0) * d - (g 1 1) * c = 1),
  {
    use -(g 0 0),
    use -(g 0 1),
    symmetry,
    convert this using 1,
    symmetry,
    convert detIs,
    ring,
  },
  have := (gcd_eq_one_iff_coprime''' (g 1 0) (g 1 1)).mp e1,
  rw ‚Üêint.coe_gcd at this,
  norm_cast at this,
  exact this,
end

def bottom_row : SL(2, ‚Ñ§) ‚Üí coprime_ints := Œª g, ‚ü®(g.1 1 0, g.1 1 1), bottom_row_coprime g‚ü©

lemma bottom_row_surj : function.surjective bottom_row :=
begin
  intros cd,
  have cop : int.gcd (cd:‚Ñ§√ó‚Ñ§).1 (cd:‚Ñ§√ó‚Ñ§).2  = 1 := cd.2,
  let a := int.gcd_b (cd:‚Ñ§√ó‚Ñ§).1 (cd:‚Ñ§√ó‚Ñ§).2,
  let b := - int.gcd_a (cd:‚Ñ§√ó‚Ñ§).1 (cd:‚Ñ§√ó‚Ñ§).2,
  let A := ![![a ,b ], ![(cd:‚Ñ§√ó‚Ñ§).1, (cd:‚Ñ§√ó‚Ñ§).2]],
  have det_A_1 : det A = 1,
  { rw det2,
    simp [a, b, A],
    have := int.gcd_eq_gcd_ab (cd:‚Ñ§√ó‚Ñ§).1 (cd:‚Ñ§√ó‚Ñ§).2,
    rw cop at this,
    symmetry,
    convert this using 1,
    ring },
  use ‚ü®A, det_A_1‚ü©,
  rw bottom_row,
  simp [A],
end

lemma exists_g_with_min_bottom (z : H) :
  ‚àÉ g : SL(2,‚Ñ§), ‚àÄ g' : SL(2,‚Ñ§), (bottom g z).norm_sq ‚â§ (bottom g' z).norm_sq  :=
begin
  haveI : nonempty coprime_ints := sorry,
  obtain ‚ü®cd, hcd‚ü©  := filter.tendsto.exists_forall_le (finite_pairs z),
  obtain ‚ü®g, hg‚ü©  := bottom_row_surj cd,
  use g,
  intros g',
  convert hcd (bottom_row g'),
  { simp [bottom_row] at hg,
    simp [bottom, ‚Üê hg], },
  simp [bottom_row],
end

lemma exists_g_with_max_Im (z : H) :
  ‚àÉ g : SL(2,‚Ñ§), ‚àÄ g' : SL(2,‚Ñ§),  (g' ‚Ä¢ z).val.im ‚â§ (g ‚Ä¢ z).val.im :=
begin
  obtain ‚ü®g, hg‚ü©  := exists_g_with_min_bottom z,
  use g,
  intros g',
  have hgg := hg g',
  rw [im_smul_SL'', im_smul_SL''],
  rwa div_le_div_left,
  { exact im_pos_of_in_H' },
  { exact norm_sq_pos.mpr (@bottom_nonzero g' z z.2) },
  { exact norm_sq_pos.mpr (@bottom_nonzero g z z.2) },
end

section
/-! This is an attempt to do the maximin argument using more abstract existence theory. -/

open filter

--instance {Œ± : Type*} [ring Œ±] [topological_space Œ±] {n m : Type*} [fintype n] [fintype m] :
 -- topological_space (matrix n m Œ±) :=
--Pi.topological_space

instance {Œ± : Type*} [ring Œ±] [metric_space Œ±] {n m : Type*} [fintype n] [fintype m] :
  metric_space (matrix n m Œ±) :=
metric_space_pi


/- This needs to be added to mathlib!!! There is `preimage_subset_preimage_iff` but it
    requires `(hs : s ‚äÜ range f)`, which is only needed in the other direction! -/
lemma preimage_subset_preimage {Œ± Œ≤ : Type*} {s t : set Œ±} {f : Œ≤ ‚Üí Œ±} :
  s ‚äÜ t ‚Üí f ‚Åª¬π' s ‚äÜ f ‚Åª¬π' t :=
begin
  intros h x, apply h
end

-- for `order.filter.basic`
lemma filter.tendsto.of_tendsto_comp {Œ≤ A B : Type*} {lŒ≤ : filter Œ≤} {lA : filter A}
  {lB : filter B} {g : A ‚Üí B} {mB : B ‚Üí Œ≤}
  (hAŒ≤ : tendsto (mB ‚àò g) lA lŒ≤) (hBŒ≤ : comap mB lŒ≤ ‚â§ lB) :
  tendsto g lA lB :=
begin
  rw tendsto_iff_comap at hAŒ≤ ‚ä¢,
  calc lA ‚â§ comap (mB ‚àò g) lŒ≤ : hAŒ≤
  ... ‚â§ comap g lB : by simpa [comap_comap] using comap_mono hBŒ≤
end

-- for `order.filter.cofinite`
lemma function.injective.tendsto_cofinite {Œ± A : Type*} {mA : A ‚Üí Œ±} (hmA : function.injective mA) :
  tendsto mA cofinite cofinite :=
Œª s h, h.preimage (hmA.inj_on _)

-- ugly, clean up somehow?
-- for `topology.subset_properties`
lemma comap_cocompact {Œ≤ B : Type*} [topological_space Œ≤] [topological_space B] {mB : B ‚Üí Œ≤}
  (hmB : continuous mB) : comap mB (cocompact Œ≤) ‚â§ cocompact B :=
begin
  intros s,
  simp only [mem_comap_sets, mem_cocompact],
  rintros ‚ü®t, ht, hts‚ü©,
  use (mB '' t)·∂ú,
  simp only [mem_cocompact],
  split,
  refine ‚ü®mB '' t, ht.image hmB, set.subset.refl _‚ü©,
  rw set.compl_subset_comm at hts,
  rw ‚Üê set.compl_subset_compl,
  refine set.subset.trans hts _,
  tidy,
end

/- Is this non-crap? (More elegant phrasing?...) We know that $‚Ñ§$ matrices are discrete in $‚Ñù$; so intersection of $Z$ matrices is discrete in line -/
lemma tendsto_inverse_image_fun {Œ± Œ≤ A B : Type*} [topological_space Œ≤] [topological_space B]
  {f : Œ± ‚Üí Œ≤} {g : A ‚Üí B} {mA : A ‚Üí Œ±} {mB : B ‚Üí Œ≤}
  (hmA : function.injective mA) (hmB : continuous mB) (h : f ‚àò mA = mB ‚àò g)
  --(h : ‚àÄ x, f (mA x) = mB (g x))
  (hf : tendsto f cofinite (cocompact _)) :
  tendsto g cofinite (cocompact _) :=
begin
  refine filter.tendsto.of_tendsto_comp _ (comap_cocompact hmB),
  simpa [h] using hf.comp hmA.tendsto_cofinite,
  -- rintros s hK,
  -- rw mem_cocompact' at hK,
  -- obtain ‚ü®K, hK1, hK2‚ü© := hK,
  -- have diag_chase : mA '' (g ‚Åª¬π' K) ‚äÜ f ‚Åª¬π' (mB '' K) := by tidy,
  -- have : (mB '' K)·∂ú ‚àà cocompact Œ≤ ,
  -- { rw mem_cocompact',
  --   refine ‚ü®mB '' K, is_compact.image hK1 hmB, _‚ü©,
  --   rw compl_compl },
  -- have : (f ‚Åª¬π' (mB '' K)).finite,
  -- { convert (filter.mem_cofinite.mp (hf this)),
  --   simp only [set.preimage_compl, compl_compl] },
  -- have : (mA '' (g ‚Åª¬π' K)).finite := set.finite.subset this diag_chase,
  -- have : (g ‚Åª¬π' K).finite,
  -- { convert set.finite.preimage _ this,
  --   exact (function.injective.preimage_image hmA (g ‚Åª¬π' K)).symm,
  --   exact set.inj_on_of_injective hmA _ },
  -- exact set.finite.subset this (preimage_subset_preimage hK2),
end



/- Is this non-crap? (More elegant phrasing?...) We know that $‚Ñ§$ matrices are discrete in $‚Ñù$; so intersection of $Z$ matrices is discrete in line -/
lemma tendsto_inverse_image_fun' {Œ± Œ≤ : Type*} [topological_space Œ≤] (A : set Œ±) (B : set Œ≤)
  {f : Œ± ‚Üí Œ≤} (hf‚ÇÅ : ‚àÄ x ‚àà A, f x ‚àà B ) (hf‚ÇÇ : tendsto f cofinite (cocompact _)) :
  tendsto (subtype.map f (Œª x h, set.mem_def.mp (hf‚ÇÅ x h))) cofinite (cocompact _) :=
begin
  refine tendsto_inverse_image_fun subtype.coe_injective continuous_subtype_coe _ hf‚ÇÇ,
  intros y,
  simp,
end

/- Non-crap lemma but put it elsewhere ?  Maybe cocompact in discrete is cofinite -/
lemma cocompact_‚Ñù_to_cofinite_‚Ñ§ (Œπ : Type*) [fintype Œπ] :
  tendsto ((Œª (p : Œπ ‚Üí ‚Ñ§), (coe : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p)) cofinite (cocompact (Œπ ‚Üí ‚Ñù)) :=
by simpa [‚ÜêCoprod_cofinite,‚ÜêCoprod_cocompact]
  using tendsto.prod_map_Coprod (Œª i, int.tendsto_coe_cofinite)



/- Non-crap lemma: ‚Ñ§ -matrices are cofinite inside comcompact ‚Ñù matrices -/
lemma cocompact_‚Ñù_to_cofinite_‚Ñ§_matrix {Œπ Œπ' : Type*} [fintype Œπ] [fintype Œπ']  :
  tendsto (Œª m, matrix.map m (coe : ‚Ñ§ ‚Üí ‚Ñù)) cofinite (cocompact (matrix Œπ Œπ' ‚Ñù)) :=
begin
--  convert tendsto.pi_map_Coprod (Œª i, cocompact_‚Ñù_to_cofinite_‚Ñ§ Œπ'),
  convert tendsto.prod_map_Coprod (Œª i, cocompact_‚Ñù_to_cofinite_‚Ñ§ Œπ'),
  { exact Coprod_cofinite.symm },
  { exact Coprod_cocompact.symm }
end


/-- method 1 -/
def line (cd : coprime_ints) : set (matrix (fin 2) (fin 2) ‚Ñù) :=
  {g | g 1 0 = (cd : ‚Ñ§ √ó ‚Ñ§).1 ‚àß g 1 1 = (cd : ‚Ñ§ √ó ‚Ñ§).2 ‚àß det g = 1}

/- Do we need this? Maybe delete
lemma line_proper (cd : coprime_ints) :
  map coe (cocompact (line cd)) = cocompact (matrix (fin 2) (fin 2) ‚Ñù) :=
begin

  sorry
end
-/


-- make `line` an affine subspace of 2x2 matrices, using the following lemma
lemma line_det (cd : coprime_ints) {g : matrix _ _ ‚Ñù} (hg : g ‚àà line cd) :
  g 0 0 * cd.1.2 - g 0 1 * cd.1.1 = 1 :=
begin
  convert hg.2.2,
  rw [det2, hg.1, hg.2.1],
  ring,
end

lemma in_line (cd : coprime_ints) {g : SL(2, ‚Ñ§)} (hg : bottom_row g = cd) :
  ‚Üë(g : SL(2, ‚Ñù)) ‚àà line cd :=
begin
  rw line,
  rw set.mem_set_of_eq,
  rw bottom_row at hg,
  simp only [subtype.val_eq_coe] at hg,
  split,
  simp [hg],
  sorry,
  split,
  simp [hg],
  sorry,
  exact (g: SL(2,‚Ñù)).2,
end

def to_line (cd : coprime_ints) (g : bottom_row ‚Åª¬π' {cd}) : line cd :=
‚ü®‚Üë(g : SL(2, ‚Ñù)), in_line cd g.2‚ü©

/- Can be deduced from ...
lemma tendsto_line (cd : coprime_ints) : tendsto (to_line cd) cofinite (cocompact _) :=
begin

  sorry
end
-/

/-
def lattice_intersect (A : set (matrix (fin 2) (fin 2) ‚Ñù)) :
  set (matrix (fin 2) (fin 2) ‚Ñ§) :=
(int.cast_ring_hom ‚Ñù).map_matrix ‚Åª¬π' (A : set (matrix (fin 2) (fin 2) ‚Ñù))


example (cd : coprime_ints) : bottom_row ‚Åª¬π' {cd} ‚Üí (lattice_intersect (line cd)) :=
set.cod_restrict (coe : bottom_row ‚Åª¬π' {cd} ‚Üí (matrix (fin 2) (fin 2) ‚Ñ§)) (lattice_intersect (line cd))
begin
  rintros ‚ü®‚ü®g, hg'‚ü©, hg‚ü©,
  simp [lattice_intersect, line] at *,
  sorry
end

def lattice_intersect_fun (A : set (matrix (fin 2) (fin 2) ‚Ñù)) :
  lattice_intersect A ‚Üí A :=
inverse_image_fun A (int.cast_ring_hom ‚Ñù).map_matrix

/-- lemma about intersection of affine subspaces with integer lattice -/
lemma tendsto_lattice_intersect_fun (A : set (matrix (fin 2) (fin 2) ‚Ñù)) :
  tendsto (lattice_intersect_fun A) cofinite (cocompact _) :=
begin
  apply tendsto_inverse_image_fun,
  { sorry },
  { exact  pi_prod_cofinite (Œª i, (pi_prod_cofinite (Œª j, int.tendsto_coe_cofinite))) }
end

-/



def smul_aux' : (matrix (fin 2) (fin 2) ‚Ñù) ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ := sorry

def acbd : (matrix (fin 2) (fin 2) ‚Ñù) ‚Üí ‚Ñù := Œª g, (g 0 0) * (g 1 0) + (g 0 1)*(g 1 1)


lemma something1 (cd : coprime_ints) (z : H) (g : line cd) :
‚àÉ w , (smul_aux' ‚Üëg z).re = (acbd g)/(real.sqrt ((cd.1.1)^2+(cd.1.2)^2)) + w :=
begin
  sorry,
end


/- Needed: Conditions on a linear transformation for a given linear functional to be tendsto cocompact cocopmact
on the kernel of the linear transformation  -/


lemma tendsto_acbd (cd : coprime_ints):
  tendsto (Œª g, acbd (‚Üëg)) (cocompact (line cd)) (cocompact ‚Ñù) :=
begin
  let cabs := _root_.abs cd.1.1,
  let dabs := _root_.abs cd.1.2,
  let maxCD := max cabs dabs,
  intros K hK ,
  rw mem_cocompact at hK,

  obtain ‚ü® K1, hK1, hK2‚ü©  := hK,

  obtain ‚ü® t, ht‚ü©  := (metric.bounded_iff_subset_ball 0).mp (is_compact.bounded hK1),
  rw mem_map,
  rw mem_cocompact,
  refine ‚ü®
  ((coe : line cd ‚Üí (matrix (fin 2) (fin 2) ‚Ñù)) ‚Åª¬π'
   (metric.closed_ball (0: matrix (fin 2) (fin 2) ‚Ñù) (max (2*(_root_.abs t)+1) maxCD) )),
   sorry, _‚ü© ,
   --simp,
  rw set.compl_subset_comm,
  rw set.compl_subset_comm at hK2,
  intros g hg,
  simp [dist_eq_norm] at hg,
  simp only [set.mem_preimage, metric.mem_closed_ball,  int_cast_abs, subtype.val_eq_coe],
  have : acbd ‚Üëg ‚àà metric.closed_ball (0:‚Ñù) t,
  {
    apply ht,
    apply hK2,
    exact hg,
  },
  rw dist_pi_def,
  let a : nnreal := nnreal.of_real (max (2 * |t| + 1) ‚ÜëmaxCD),
  rw ‚Üê nnreal.coe_of_real (max (2 * |t| + 1) ‚ÜëmaxCD),
  norm_cast,
  have : (‚àÄ (b : fin 2), b ‚àà finset.univ ‚Üí (Œª (b : fin 2), nndist ((‚Üëg: matrix _ _ ‚Ñù) b) 0) b ‚â§ a) := sorry,
  refine @finset.sup_le nnreal (fin 2) _ (finset.univ) ((Œª (b : fin 2), nndist ((‚Üëg: matrix _ _ ‚Ñù) b) (0))) a _,

  sorry
end

/- Non-crap lemma: given the line of cd, the real part of the action of g on z is cocompact -/
lemma tendsto_action (cd : coprime_ints) (z : H) :
  tendsto (Œª g, (smul_aux' ‚Üëg z).re) (cocompact (line cd)) (cocompact ‚Ñù) :=
begin
  -- let g : ‚Ñù ‚Üí matrix (fin 2) (fin 2) ‚Ñù :=

  have := something1 cd z,
  sorry
end

/- Non-crap lemma: Absolute value function is cocompact -/
lemma tendsto_at_top_abs :
  tendsto _root_.abs (cocompact ‚Ñù) at_top :=
begin
  rw has_basis_cocompact.tendsto_iff at_top_basis_Ioi,
  { refine Œª b _, ‚ü®set.Icc (-b) b, compact_Icc, Œª x hx, _‚ü©,
    simpa [lt_abs, or_comm, lt_neg, not_and_distrib] using hx },
  { apply_instance },
  { apply_instance }
end

lemma sddsf (cd : coprime_ints) (z : ‚ÑÇ) :
  tendsto (Œª g : lattice_intersect (line cd), _root_.abs (smul_aux' ‚Üë(lattice_intersect_fun _ g) z).re)
    cofinite at_top :=
(tendsto_at_top_abs.comp (tendsto_action cd z)).comp (tendsto_lattice_intersect_fun (line cd))

/-- method 2 -/
def line' (cd : coprime_ints) : set (‚Ñù √ó ‚Ñù) :=
  {ab | ab.1 * (cd : ‚Ñ§ √ó ‚Ñ§).2 - ab.2 * (cd : ‚Ñ§ √ó ‚Ñ§).1 = 1}

def in_line' (cd : coprime_ints) {g : SL(2, ‚Ñ§)} (hg : bottom_row g = cd) :
  (‚Üë(g 0 0), ‚Üë(g 0 1)) ‚àà line' cd :=
sorry

def to_line' (cd : coprime_ints) (g : bottom_row ‚Åª¬π' {cd}) : line' cd :=
‚ü®(g 0 0, g 0 1), in_line' cd g.2‚ü©

lemma tendsto_line' (cd : coprime_ints) : tendsto (to_line' cd) cofinite (cocompact _) := sorry

lemma inv_image_eq_line (cd : coprime_ints) :
  bottom_row ‚Åª¬π' {cd} = (prod.map coe coe : ‚Ñ§ √ó ‚Ñ§ ‚Üí ‚Ñù √ó ‚Ñù) ‚Åª¬π' line cd :=
sorry

end

/- Non-crap lemma but content-free; should be combination of building blocks -/
lemma something' (z:H) (cd : coprime_ints) :
  tendsto (Œª g : bottom_row ‚Åª¬π' {cd}, _root_.abs (((g : SL(2, ‚Ñ§)) ‚Ä¢ z).val.re)) cofinite at_top :=
begin

end

lemma something (z:H) (cd : coprime_ints) :
  ‚àÉ g : SL(2,‚Ñ§), bottom_row g = cd ‚àß (‚àÄ g' : SL(2,‚Ñ§), bottom_row g = bottom_row g' ‚Üí
  _root_.abs ((g ‚Ä¢ z).val.re) ‚â§ _root_.abs ((g' ‚Ä¢ z).val.re)) :=
begin

  sorry,
end

variables {g : SL(2,‚Ñ§)} {z : H}

lemma im_S_z {z : H} : (S ‚Ä¢ z).val.im = z.val.im / z.val.norm_sq :=
begin
  rw im_smul_SL'',
  rw bottom,
  simp,
  rw S,
  simp,
end

lemma im_lt_im_S {z : H} (h: norm_sq z.val < 1) : z.val.im < (S ‚Ä¢ z).val.im :=
begin
  rw im_S_z,
  have imz : 0 < z.val.im := im_pos_of_in_H',
  have hnz : 0 < norm_sq z.val,
  {
    rw norm_sq_pos,
    intro h,
    rw h at imz,
    rw zero_im at imz,
    linarith,
  },
  set N := norm_sq z.val with hN,
  set zim := z.val.im with hzim,
  have : zim * N < zim, by nlinarith,
  exact (lt_div_iff hnz).mpr this,
end

/- TODO : prove directly instead of by contradiction
-/
lemma norm_sq_ge_one_of_act_S {z : H} (h : (S ‚Ä¢ z).val.im ‚â§ z.val.im) : 1 ‚â§ norm_sq z.val :=
begin
  by_contradiction hcontra,
  push_neg at hcontra,
  have := im_lt_im_S hcontra,
  linarith,
end

lemma T_inv_action {z : H} : (T‚Åª¬π ‚Ä¢ z).1 = z - 1 :=
begin
  convert @smul_sound (T‚Åª¬π) z,
  rw smul_aux,
  rw T_inv,
  simp,
  ring,
end

lemma half_ge_x_T_inv (x : ‚Ñù) (h : 1/2 < x) : |x - 1| < x :=
begin
  have : -(x) < x-1 ‚àß x-1 < x := by split; linarith,
  exact abs_lt.mpr this,
end

lemma half_le_neg_x_T (x : ‚Ñù) (h : 1/2 < -x) : |x + 1| < |x| :=
begin
  have : -|x| < x+1 ‚àß x+1 < |x|,
  { have : |x| = -x,
    { refine _root_.abs_of_neg _,
      linarith },
    rw this,
    split; linarith },
  exact abs_lt.mpr this,
end

lemma re_ge_half_of_act_T {z : H}
(h: 1/2 < _root_.abs (z:‚ÑÇ).re)
:
((_root_.abs (T ‚Ä¢ z).val.re) < _root_.abs z.val.re) ‚à®
((_root_.abs (T‚Åª¬π ‚Ä¢ z).val.re) < _root_.abs z.val.re)
:=
begin
  rw T_action,
  rw T_inv_action,
  let x := z.val.re,
  simp,
  rw lt_abs at h,
  cases h,
  { right,
    convert (half_ge_x_T_inv ((z:‚ÑÇ).re) h),
    exact _root_.abs_of_nonneg (by linarith) },
  { left,
    exact half_le_neg_x_T (z:‚ÑÇ).re h },
end

lemma bot_row_eq_diff_by_unipotent (g g' : SL(2,‚Ñù)) (h : bottom_row g = bottom_row g') :
‚àÉ (x:‚Ñù), g = (![![1,x],![0,1]],_) * g' :=
begin
  -- human proof: g= a,b,c,d, g' = a' b' c d (same c d!)
  -- then g*g‚Åª¬π = (a b c d)(d -b' -c a') = (1 * 0 1)

--  let ![![a,b],![c,d]] := g.1,
  let Tn := g * g'‚Åª¬π,
  sorry,

end

lemma find_g_with_min_re (z:H) (cd : coprime_ints) :
‚àÉ g : SL(2,‚Ñ§), bottom_row g = cd ‚àß (‚àÄ g' : SL(2,‚Ñ§),  bottom_row g = bottom_row g' ‚Üí
_root_.abs ((g ‚Ä¢ z).val.re) ‚â§ _root_.abs ((g' ‚Ä¢ z).val.re)) :=
begin
/-  -- Argh this is all wrong;
-- Need to look somehow at the set of all preimages of cd
-- among those, choose g with minimal real part
-- the rest is tautological
  obtain ‚ü®g, hg‚ü© := bottom_row_surj cd,
  use g,
  split,
  exact hg,
  intros g' hg',
  by_contradiction hcontra,
  push_neg at hcontra,
  obtain ‚ü®n, hn‚ü© := bot_row_eq_diff_by_T_n g g' hg',
  rw hn at hcontra,
  -/
  sorry,
end



lemma is_fundom {z : H} : ‚àÉ g : SL(2,‚Ñ§), g ‚Ä¢ z ‚àà ùíü :=
begin
  obtain ‚ü®g, hg2‚ü© := exists_g_with_max_Im z,
  obtain ‚ü®n, hn‚ü© := find_appropriate_T ((g : SL(2,‚Ñ§)) ‚Ä¢ z),
  use (T^n * g),
  have hS : S ‚àà G' := by {apply subgroup.mem_closure', simp},
  have hT : T ‚àà G' := by {apply subgroup.mem_closure', simp},
  have hTn : T^n ‚àà G' := by {apply subgroup.gpow_mem G' hT},
--  have hTng : T^n * g ‚àà G' := G'.mul_mem hTn hg1,
--  have hSTg : S * T^n * g ‚àà G' := G'.mul_mem (G'.mul_mem hS hTn) hg1,
  replace hg2 := hg2 (S * T^n * g), -- hSTg,
  set z' := (T^n * g) ‚Ä¢ z with z'df,
  have imz' : z'.val.im = ((g : SL(2,‚Ñ§)) ‚Ä¢ z).val.im,
  { rw [z'df, ‚Üê smul_smul, im_Tn_z] },
  rw smul_smul at hn,
  change |z'.val.re| ‚â§ 1 / 2 at hn,
  suffices : 1 ‚â§ z'.1.norm_sq,
  -- by exact ‚ü®hTn,‚ü®this, hn‚ü©‚ü©,
  {
    exact ‚ü®this, hn‚ü©,
  },

  set w := (S * T^n * g) ‚Ä¢ z with hw,
  apply norm_sq_ge_one_of_act_S,
  replace hw : w = S‚Ä¢z',
  {rw [hw, z'df, smul_smul, mul_assoc]},
  rw [imz', ‚Üê hw],
  exact hg2,
end

@[simp]
lemma fundom_aux_1 {z : H} (hz : z ‚àà ùíü) (h' : T ‚Ä¢ z ‚àà ùíü) : z.val.re = -1/2 := sorry

@[simp]
lemma fundom_aux_2 {z : H} (hz : z ‚àà ùíü) (h' : T‚Åª¬π ‚Ä¢ z ‚àà ùíü) : z.val.re = 1/2 := sorry

@[simp]
lemma fundom_aux_3 {z : H} (hz : z ‚àà ùíü) (h' : S ‚Ä¢ z ‚àà ùíü) : z.val.abs = 1 := sorry

/- Why is this not doable by linarith directly? -/
example {a b : ‚Ñù} (ha : 0 < a) (hb : 0 < b) (h : a ‚â§ a / b) : b ‚â§ 1 :=
begin
  suffices: a * b ‚â§ a, nlinarith,
  rw le_div_iff hb at h,
  exact h,
end

lemma namedIs (c :‚Ñï ) (h: c‚â§ 1) :  c=0 ‚à® c=1 :=
begin
  cases nat.of_le_succ h,
  {
    left,
    exact le_zero_iff.mp h_1,
  },
  right,
  exact h_1,
end

lemma namedIsZ (c :‚Ñ§  ) (h: c‚â§ 1) (h2: 0‚â§ c) :  c=0 ‚à® c=1 :=
begin
  --lift n to ‚Ñï using hn
  lift c to ‚Ñï using h2,
  norm_cast,
  refine namedIs _ _ ,
  exact_mod_cast h,
end

-- Describe closure of D as union of boundary segments and interior.
-- Then the lemma goes by cases on where z and z'

lemma fundom_no_repeats' (z z' : H) (h : ‚àÉ g : SL(2,‚Ñ§), z' = g ‚Ä¢ z) (hz : z ‚àà ùíü') (hz' : z' ‚àà ùíü') :
  (z = z') :=
begin
  sorry,
end

lemma is_fundom'' {z : H} : ‚àÉ g : SL(2,‚Ñ§), g ‚Ä¢ z ‚àà closure fundamental_domain' :=
begin
  sorry,
end


lemma fundom_no_repeats (z z' : H) (h : ‚àÉ g : SL(2,‚Ñ§), z' = g ‚Ä¢ z) (hz : z ‚àà ùíü) (hz' : z' ‚àà ùíü) :
  (z = z') ‚à®
  (z.val.re = -1/2 ‚àß z' = T ‚Ä¢ z) ‚à®
  (z'.val.re = -1/2 ‚àß z = T ‚Ä¢ z') ‚à®
  (z.val.abs = 1 ‚àß z'.val.abs = 1 ‚àß z' = S ‚Ä¢ z ‚àß z = S ‚Ä¢ z') :=
begin
  wlog hwlog : z.val.im ‚â§ z'.val.im,
  {
    by_cases hne : z = z', tauto,
    right,
    replace h := sign_coef h,
    obtain ‚ü®g, hcpos, hac, hg‚ü© := h,
    set a := g.1 0 0,
    set b := g.1 0 1,
    set c := g.1 1 0 with ‚Üêcdf,
    set d := g.1 1 1 with ‚Üêddf,
    have hcd : complex.norm_sq (c * z + d) ‚â§ 1,
    {
      have himzpos : 0 < z.val.im := im_pos_of_in_H',
      have hnz : 0 < complex.norm_sq (c * z + d),
      {
        rw norm_sq_pos,
        intro hcontra,
        rw [‚Üê cdf, ‚Üê ddf, ‚Üê bottom_def] at hcontra,
        exact czPd_nonZ_CP (ne.symm (ne_of_lt himzpos)) hcontra,
      },
      suffices: z.val.im * complex.norm_sq (c * z + d) ‚â§ z.val.im, nlinarith,
      rw [hg, im_smul_SL',cdf,ddf, le_div_iff hnz] at hwlog,
      exact hwlog,
    },
    have hc : _root_.abs c ‚â§ 1,
    {
      sorry
    },
    replace hc : c = 0 ‚à® c = 1,
    {

      rw abs_le at hc,
      exact namedIsZ c hc.2 hcpos,
    },
    rcases hc with  hc | hc ,
    { -- case c = 0
      have ha : a = 1 := (hac hc).2,
      have hd : d = 1 := (hac hc).1,
      have hgT : g = T^b,
      {
        rw T_pow,
        apply subtype.eq,
        simp,
        tauto,
      },
      have hb : _root_.abs c ‚â§ 1,
      {
        sorry
      },
      replace hb : b = -1 ‚à® b = 0 ‚à® b = 1,
      {
        sorry
      },
      rcases hb with hb | hb | hb,
      all_goals {rw hb at hgT, rw hgT at hg, clear hb, clear hgT, simp at hg},
      {
        right, left,
        rw ‚Üêinv_smul_eq_iff at hg,
        rw ‚Üêhg at hz,
        rw fundom_aux_1 hz' hz,
        tauto,
      },
      { tauto },
      {
        left,
        rw hg at hz',
        rw fundom_aux_1 hz hz',
        tauto,
      }
    },
    { -- case c = 1
      sorry
    }
  },
  obtain ‚ü®g, hg‚ü© := h,
  have hh : ‚àÉ g : SL(2,‚Ñ§), z = g ‚Ä¢ z' := ‚ü®g‚Åª¬π, by {simp [eq_inv_smul_iff, hg]}‚ü©,
  specialize this hh hz' hz,
  tauto,
end


-- define fundamental domain
-- open region, g.z=w -> g=1
-- all z in H, exists g in G such that g.z in closure F

-- define std domain {|z|>1, |z.re| <1/2}

-- proof std domain is a fund dom for G

-- define modular form1

-- define Eisenstein series

-- prove E-sereis are modular

-- E(z,k):= sum _{(c,d)‚àà Z^2\ {0,0}} 1/(cz+d)^k

/-
  human:
  d/ dz E(z,k):= sum _{(c,d)‚àà Z^2\ {0,0}}  d/ dz 1/(cz+d)^k

  OR

  E(z,k) - E(w,k)
  =
  sum _{(c,d)‚àà Z^2\ {0,0}}  ( 1/(cz+d)^k -  1/(cw+d)^k)
=
(z-w)   *
  sum _{(c,d)‚àà Z^2\ {0,0}}  ( 1/(cz+d)^k -  1/(cw+d)^k)

-/

/- define Ramanujan delta

-/


-- @[simp]
-- lemma coeff_coe {g : SL(2,‚Ñ§)} {i j : fin 2} : (g : SL(2,‚Ñù)).val i j = ((g.val i j) : ‚Ñù) := by refl

-- @[simp]
-- lemma coeff_coe' {g : SL(2,‚Ñ§)} {i j : fin 2} : (g : SL(2,‚Ñù)) i j = ((g i j) : ‚Ñù) := by refl

-- lemma div_eq_mul_conj_div_norm_sq {z w : ‚ÑÇ} : z / w = (z * (w.conj)) / complex.norm_sq w :=
-- begin
--   rw [div_eq_mul_inv, inv_def, div_eq_mul_inv, mul_assoc],
--   norm_num,
-- end


-- @[simp]
-- lemma mul_congr { x y : SL(2,‚Ñ§)} : x * y = 1 ‚Üî x.1 * y.1 = 1 := by simp




-- lemma e14 : at_top ‚â§ cocompact ‚Ñù :=
-- begin
--   intros s hs,
--   simp only [mem_at_top_sets],
--   simp only [mem_cocompact] at hs,
--   obtain ‚ü®t, ht, hts‚ü© := hs,
--   obtain ‚ü®r, hr‚ü© := e7 ht.bounded,
--   use r + 1,
--   intros b hb,
--   apply hts,
--   intros hb',
--   have := hr _ hb',
--   simp only [real.norm_eq_abs, abs_le] at this,
--   linarith
-- end

-- lemma e16 {E : Type*} [normed_group E] [normed_space ‚Ñù E] [proper_space E] [nontrivial E] (s : set ‚Ñù) :
--   norm ‚Åª¬π' s ‚àà cocompact E ‚Üî s ‚àà (at_top : filter ‚Ñù) :=
-- begin
--   rw [mem_at_top_sets, mem_cocompact],
--   split,
--   { rintros ‚ü®t, ht, hts‚ü©,
--     obtain ‚ü®r, hr‚ü© := e7 ht.bounded,
--     use r + 1,
--     intros b hb,
--     obtain ‚ü®x, hx‚ü© : ‚àÉ x : E, x ‚â† 0 := exists_ne 0,
--     have h_norm : ‚à•b ‚Ä¢ (‚à•x‚à•)‚Åª¬π ‚Ä¢ x‚à• = b := sorry,
--     have : b ‚Ä¢ (‚à•x‚à•)‚Åª¬π ‚Ä¢ x ‚àà t·∂ú,
--     { have := mt (hr (b ‚Ä¢ (‚à•x‚à•)‚Åª¬π ‚Ä¢ x)),
--       apply this,
--       linarith },
--     simpa [h_norm] using hts this },
--   { rintros ‚ü®r, hr‚ü©,
--     refine ‚ü®metric.closed_ball 0 r, proper_space.compact_ball 0 r, _‚ü©,
--     intros x hx,
--     simp at hx,
--     exact hr (‚à•x‚à•) hx.le },
-- end

-- lemma e17 {E : Type*} [normed_group E] [normed_space ‚Ñù E] [proper_space E] [nontrivial E] :
--   map norm (cocompact E) = (at_top : filter ‚Ñù) :=
-- begin
--   ext s,
--   exact e16 s
-- end

-- lemma e15 {Œ± : Type*} {E : Type*} [normed_group E] [normed_space ‚Ñù E] [proper_space E] [nontrivial E] (l : filter Œ±) {f : Œ± ‚Üí E} :
--   tendsto f l (cocompact E) ‚Üî tendsto (norm ‚àò f) l at_top :=
-- begin
--   split,
--   { exact tendsto_norm_cocompact_at_top.comp },
--   sorry
-- end


-- lemma finite_integers {M : ‚Ñù} :
--   set.finite {c : ‚Ñ§ | |(c : ‚Ñù)| ‚â§ M } :=
-- begin
--     let s:= finset.Ico_‚Ñ§ (‚åä-M‚åã) (‚åäM‚åã+1),
--     suffices : {c : ‚Ñ§ | |‚Üëc| ‚â§ M} ‚äÜ  s,
--     {
--       refine set.finite.subset s.finite_to_set this,
--     },
--     intros c,
--     simp [s],
--     intros h,
--     rw abs_le at h,
--     have h1 := h.1,
--     have h2 := h.2,
--     split,
--     {
--       have : (‚åä-M‚åã :‚Ñù ) ‚â§ -M :=  floor_le (-M),
--       have := le_trans this h1,
--       exact_mod_cast this,
--     },
--     {
--       have : (c:‚Ñù ) < (‚åäM‚åã:‚Ñù) + 1,
--       {
--         calc
--         (c:‚Ñù) ‚â§ M           : h2
--         ...   < (‚åäM‚åã:‚Ñù) + 1 : M_lt_Mp1 M,
--       },

--       norm_cast at this,
--       exact this,
--     },
-- end

-- -- for `normed_space.basic`
-- lemma metric.bounded.exists_norm_le {Œ± : Type*} [normed_group Œ±] {s : set Œ±} (hs : metric.bounded s) :
--   ‚àÉ R, ‚àÄ x ‚àà s, ‚à•x‚à• ‚â§ R :=
-- begin
--   rcases s.eq_empty_or_nonempty with (rfl | hs'),
--   { simp },
--   obtain ‚ü®R‚ÇÅ, hR‚ÇÅ‚ü© := hs,
--   obtain ‚ü®x, hx‚ü© := hs',
--   use ‚à•x‚à• + R‚ÇÅ,
--   intros y hy,
--   have : ‚à•x - y‚à• ‚â§ R‚ÇÅ := by simpa [dist_eq_norm] using hR‚ÇÅ x y hx hy,
--   have := norm_le_insert x y,
--   linarith
-- end

-- -- for `order.filter.basic`
-- lemma e9 {Œ± : Type*} (l : filter Œ±) {s t : set Œ±} (hst : s ‚à™ t·∂ú ‚àà l) (ht : t ‚àà l) : s ‚àà l :=
-- begin
--   refine mem_sets_of_superset _ (s.inter_subset_left t),
--   convert inter_mem_sets hst ht using 1,
--   ext,
--   simp only [set.mem_inter_eq, set.mem_union_eq, set.mem_compl_eq],
--   finish
-- end


-- lemma e10 {Œ± : Type*} {l : filter Œ±} {E F : Type*} [normed_group E] [normed_group F] [proper_space E]
--   {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} (h : asymptotics.is_O f g l) (hf : tendsto f l (cocompact E)) :
--   tendsto g l (cocompact F) :=
-- begin
--   rw tendsto_def at ‚ä¢ hf,
--   intros s hs,
--   simp [filter.mem_cocompact'] at hs,
--   obtain ‚ü®t, ht, hts‚ü© := hs,
--   obtain ‚ü®r, hr‚ü© : ‚àÉ r, ‚àÄ p ‚àà s·∂ú, ‚à•p‚à• ‚â§ r := (ht.bounded.subset hts).exists_norm_le,
--   rw asymptotics.is_O_iff at h,
--   obtain ‚ü®c, hc‚ü© := h,
--   rw eventually_iff_exists_mem at hc,
--   obtain ‚ü®v, hv, hvfg‚ü© := hc,
--   have : ‚àÄ x ‚àà v ‚à© g ‚Åª¬π' s·∂ú, x ‚àà f ‚Åª¬π' metric.closed_ball (0:E) (c * r),
--   { rintros x ‚ü®hxv, hxgs‚ü©,
--     have := hr (g x) hxgs,
--     have := hvfg x hxv,
--     simp,
--     sorry },
--   have h‚ÇÇ : f ‚Åª¬π' (metric.closed_ball (0:E) (c * r))·∂ú ‚äÜ g ‚Åª¬π' s ‚à™ v·∂ú,
--   { intros x,
--     have := this x,
--     simp only [set.mem_preimage, set.mem_inter_eq, set.mem_compl_eq] at this,
--     simp only [set.mem_preimage, set.mem_union_eq, set.mem_compl_eq],
--     contrapose!,
--     finish },
--   have h‚ÇÉ : f ‚Åª¬π' (metric.closed_ball 0 (c * r))·∂ú ‚àà l,
--   { apply hf (metric.closed_ball (0:E) (c * r))·∂ú,
--     simp only [mem_cocompact'],
--     refine ‚ü®metric.closed_ball (0:E) (c * r), proper_space.compact_ball 0 (c * r), _‚ü©,
--     simp },
--   have : g ‚Åª¬π' s ‚à™ v·∂ú ‚àà l := mem_sets_of_superset h‚ÇÉ h‚ÇÇ,
--   refine e9 l this hv
-- end


-- lemma tendsto_cocompact_of_antilipschitz {Œ± Œ≤ : Type*} [metric_space Œ±] [proper_space Œ±]
--   [metric_space Œ≤] {c : nnreal} {f : Œ± ‚Üí Œ≤} (hf : antilipschitz_with c f) :
--   tendsto f (cocompact Œ±) (cocompact Œ≤) :=
-- begin
--   rw tendsto_iff_eventually,
--   simp only [mem_cocompact, eventually_iff_exists_mem],
--   rintros p ‚ü®v, hv, hvp‚ü©,
--   rw mem_cocompact' at hv,
--   obtain ‚ü®t, ht, htv‚ü© := hv,
--   obtain ‚ü®r, hr‚ü© := ht.bounded,
--   -- have := hf.bounded_preimage ht.bounded,
--   by_cases h : ‚àÉ x, ¬¨ p (f x),
--   { obtain ‚ü®x, hx‚ü© := h,
--     have hxt : f x ‚àà t := htv (mt (hvp (f x)) hx),
--     refine ‚ü®(metric.closed_ball x (c * r))·∂ú, _, _‚ü©,
--     { rw mem_cocompact,
--       refine ‚ü®metric.closed_ball x (c * r), proper_space.compact_ball x (‚Üëc * r), rfl.subset‚ü© },
--     intros x' hx',
--     have hxx'r : r < dist (f x) (f x'),
--     { simp at hx',
--       rw dist_comm at hx',
--       rw antilipschitz_with_iff_le_mul_dist at hf,
--       have : dist x x' ‚â§ c * dist (f x) (f x') := hf x x',
--       have := lt_of_lt_of_le hx' this,
--       sorry }, -- this follows from the previous line except with a special case for `c = 0`
--     have := mt (hr (f x) (f x') hxt),
--     push_neg at this,
--     have := (mt (@htv (f x'))) (this hxx'r),
--     apply hvp,
--     simpa using this },
--   { push_neg at h,
--     refine ‚ü®set.univ, univ_mem_sets, _‚ü©,
--     intros x hx,
--     exact h x },
-- end

-- lemma tendsto_at_top_sum_sq :
--   tendsto (Œª x : ‚Ñù √ó ‚Ñù, x.1 ^ 2 + x.2 ^ 2) (cocompact (‚Ñù √ó ‚Ñù)) at_top :=
-- begin
--   refine tendsto_at_top_mono _
--     (tendsto_norm_cocompact_at_top.at_top_mul_at_top tendsto_norm_cocompact_at_top),
--   rintros ‚ü®x‚ÇÅ, x‚ÇÇ‚ü©,
--   simp only [prod.norm_def, real.norm_eq_abs],
--   cases max_choice (|x‚ÇÅ|) (|x‚ÇÇ|) with h h;
--   { rw [h, abs_mul_abs_self],
--     nlinarith },
-- end

-- @[simp] lemma expand_sum_01 {R : Type*} [ring R] (f : fin 2 ‚Üí R ) :
-- (‚àë (x : fin 2), f x) = f 0 + f 1 :=
-- by simp [fin.sum_univ_succ]
