/-
Copyright (c) 2022 Chris Birkbeck. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Chris Birkbeck
-/
import algebra.module.submodule
import mod_forms.upper_half_plane
import linear_algebra.general_linear_group
import linear_algebra.special_linear_group
--import algebra.direct_sum.ring
import mod_forms.modular
import mod_forms.mfderiv
import geometry.manifold.mfderiv


/-!
# Modular forms

This file defines modular forms and proves some basic properties about them.

We begin by defining the `slash_k` operator on the space of functions `‚Ñç ‚Üí ‚ÑÇ` and from this
define the notion of weakly modular form.

We then define `bounded_at_infinity` and `zero_at_infinity`. Finally we construct the vector
space of modular forms and prove that the product of two modular forms is a modular form
(of higher weight).
-/

open complex

open_locale topological_space manifold upper_half_plane

noncomputable theory

local notation `‚Ñç'`:=(‚ü®upper_half_plane.upper_half_space ,
 upper_half_plane.upper_half_plane_is_open‚ü©: topological_space.opens ‚ÑÇ)

local prefix `‚Üë‚Çò`:1024 := @coe _ (matrix (fin 2) (fin 2) _) _

local notation `GL(` n `, ` R `)`‚Å∫:= matrix.GL_pos (fin n) R

local notation `SL(` n `, ` R `)`:= matrix.special_linear_group (fin n) R

variable (M : GL(2, ‚Ñù)‚Å∫)

def slash_k : ‚Ñ§ ‚Üí GL(2, ‚Ñù)‚Å∫ ‚Üí (‚Ñç ‚Üí ‚ÑÇ) ‚Üí (‚Ñç ‚Üí ‚ÑÇ) := Œª k Œ≥ f,
  (Œª (x : ‚Ñç), f (Œ≥ ‚Ä¢ x) * (((‚Üë‚Çò Œ≥).det ) : ‚Ñù)^(k-1) * (((‚Üë‚Çò Œ≥ 1 0 : ‚Ñù) * x +(‚Üë‚Çò Œ≥ 1 1 : ‚Ñù))^k)‚Åª¬π)

namespace modular_forms

variables (Œì : subgroup SL(2,‚Ñ§)) (C : GL(2, ‚Ñù)‚Å∫) (k: ‚Ñ§) (f : (‚Ñç ‚Üí ‚ÑÇ))

localized "notation  f  ` ‚à£[`:100 k `]`:0 Œ≥ :100 := slash_k k Œ≥ f" in modular_form

lemma slash_k_right_action (k : ‚Ñ§) (A B : GL(2, ‚Ñù)‚Å∫) (f : ‚Ñç ‚Üí ‚ÑÇ ) :
  (f ‚à£[k] A) ‚à£[k] B = f ‚à£[k] (A * B) :=
begin
  simp_rw slash_k,
  ext1,
  have e1 := upper_half_plane.denom_cocycle A B x,
  have e3 : (A * B) ‚Ä¢ x = A ‚Ä¢ B ‚Ä¢ x := (upper_half_plane.mul_smul' A B x),
  simp only [upper_half_plane.num, upper_half_plane.denom, of_real_mul, subgroup.coe_mul, coe_coe,
    upper_half_plane.coe_smul, units.coe_mul, matrix.mul_eq_mul, matrix.det_mul,
    upper_half_plane.smul_aux, upper_half_plane.smul_aux', subtype.coe_mk] at *,
  rw [e1, e3],
  ring_nf,
  have aux1 : ‚àÄ (a b c d e : ‚ÑÇ), (e ^ k)‚Åª¬π * a ^ (k - 1) * (b ^ k)‚Åª¬π * c ^ (k - 1) * d =
    ((b * e) ^ k)‚Åª¬π * (c * a) ^ (k - 1) * d := by { intros, simp_rw [mul_zpow‚ÇÄ, mul_inv‚ÇÄ], ring, },
  simp_rw aux1,
end

lemma slash_k_add (k : ‚Ñ§) (A : GL(2, ‚Ñù)‚Å∫) (f g : ‚Ñç ‚Üí ‚ÑÇ) :
  (f + g) ‚à£[k] A = (f ‚à£[k] A) + (g ‚à£[k] A) :=
begin
  simp only [slash_k, pi.add_apply, matrix.general_linear_group.coe_det_apply, subtype.val_eq_coe,
    coe_coe],
  ext1,
  simp only [pi.add_apply],
  ring,
end

lemma slash_k_mul_one (k : ‚Ñ§) (f : ‚Ñç ‚Üí ‚ÑÇ) : (f ‚à£[k] 1) = f :=
begin
 simp_rw slash_k,
 ext1,
 simp,
end

/- FIXME FIXME -- this is hideous, I cannot find a way of deducing this from the above;
lean refuses to identify the two 1's. -/
lemma slash_k_mul_one_SL2 (k : ‚Ñ§) (f : ‚Ñç ‚Üí ‚ÑÇ) : (f ‚à£[k] (1 : SL(2, ‚Ñ§))) = f :=
begin
  simp_rw slash_k,
  simp only [coe_coe, matrix.special_linear_group.coe_GL_pos_coe_GL_coe_matrix,
    matrix.special_linear_group.coe_matrix_coe, matrix.special_linear_group.coe_one,
    int.coe_cast_ring_hom, matrix.map_one, int.cast_eq_zero, int.cast_one,
    matrix.det_one, of_real_one, one_zpow‚ÇÄ, mul_one, matrix.one_apply_ne, ne.def,
    fin.one_eq_zero_iff, nat.one_ne_zero, not_false_iff, of_real_zero, zero_mul,
    matrix.one_apply_eq, zero_add, inv_one],
  ext1, congr' 1, ext1,
  rw [upper_half_plane.coe_smul], simp,
end

lemma smul_slash_k (k : ‚Ñ§) (A : GL(2, ‚Ñù)‚Å∫) (f : ‚Ñç ‚Üí ‚ÑÇ) (c : ‚ÑÇ) : (c ‚Ä¢ f) ‚à£[k] A = c ‚Ä¢ (f ‚à£[k] A):=
begin
  ext1,
  simp_rw slash_k,
  simp only [algebra.id.smul_eq_mul, matrix.general_linear_group.coe_det_apply, pi.smul_apply,
    subtype.val_eq_coe, coe_coe],
  ring,
end

lemma slash_k_mul (k1 k2 : ‚Ñ§) (A : GL(2, ‚Ñù)‚Å∫) (f g : ‚Ñç ‚Üí ‚ÑÇ) :
  (f * g) ‚à£[k1+k2] A = (((‚Üë‚Çò A).det) : ‚Ñù) ‚Ä¢ (f ‚à£[k1] A) * (g ‚à£[k2] A) :=
begin
  ext1,
  simp [slash_k, matrix.general_linear_group.coe_det_apply, subtype.val_eq_coe, coe_coe,
  ‚Üêmul_assoc],
  rw  pi.mul_apply,
  have h1 : ((((‚Üë‚Çò A).det) : ‚Ñù) ^ (k1 + k2 - 1) : ‚ÑÇ) =
  (((‚Üë‚Çò A).det) : ‚Ñù) * (((‚Üë‚Çò A).det) : ‚Ñù) ^ (k1 - 1) * (((‚Üë‚Çò A).det) : ‚Ñù) ^ (k2 - 1),
  { simp only [mul_assoc, matrix.general_linear_group.coe_det_apply, subtype.val_eq_coe, coe_coe],
    rw [‚Üêzpow_add‚ÇÄ, ‚Üêzpow_one_add‚ÇÄ],
    ring_exp,
    all_goals
    { have hd := (matrix.mem_GL_pos _).1 A.2,
      simp only [subtype.val_eq_coe, matrix.general_linear_group.coe_det_apply] at hd,
      norm_cast,
     apply ne_of_gt hd,}, },
  simp only [matrix.general_linear_group.coe_det_apply, subtype.val_eq_coe, coe_coe] at h1,
  rw h1,
  have h2 : ((((‚Üë‚ÇòA 1 0 : ‚Ñù) : ‚ÑÇ) * (x : ‚ÑÇ) + ((‚Üë‚ÇòA 1 1 : ‚Ñù)))^(k1 + k2))‚Åª¬π =
  ((((‚Üë‚ÇòA 1 0 : ‚Ñù) : ‚ÑÇ) * (x : ‚ÑÇ) + ((‚Üë‚ÇòA 1 1 : ‚Ñù)))^k1)‚Åª¬π *
  ((((‚Üë‚ÇòA 1 0 : ‚Ñù) : ‚ÑÇ) * (x : ‚ÑÇ) + ((‚Üë‚ÇòA 1 1 : ‚Ñù)))^k2)‚Åª¬π,
  { simp_rw ‚Üê mul_inv‚ÇÄ,
    simp only [coe_coe, inv_inj],
    apply zpow_add‚ÇÄ (upper_half_plane.denom_ne_zero A x), },
  simp only [coe_coe] at h2,
  rw h2,
  ring,
end

lemma slash_k_mul_SL2 (k1 k2 : ‚Ñ§) (A : SL(2, ‚Ñ§)) (f g : ‚Ñç ‚Üí ‚ÑÇ) :
  (f * g) ‚à£[k1 + k2] A = (f ‚à£[k1] A) * (g ‚à£[k2] A) :=
begin
  have : (((‚Üë‚Çò(A : GL(2,‚Ñù)‚Å∫)).det): ‚Ñù) = 1,
  { simp only [coe_coe,matrix.special_linear_group.coe_GL_pos_coe_GL_coe_matrix,
  matrix.special_linear_group.det_coe], },
  simp_rw [slash_k_mul, this, one_smul],
end

/-- The space of weakly modular functions of weight `k` and level `Œì` -/
def weakly_modular_submodule (k : ‚Ñ§) (Œì : subgroup SL(2, ‚Ñ§)): submodule ‚ÑÇ (‚Ñç ‚Üí ‚ÑÇ) :=
{ carrier := {f : ‚Ñç ‚Üí ‚ÑÇ | ‚àÄ (Œ≥ : Œì), f ‚à£[k] Œ≥ = f },
  zero_mem' := by
  { simp only [set.mem_set_of_eq, coe_coe],
    simp_rw slash_k,
    simp only [forall_const, zero_mul, pi.zero_apply],
    refl, },
  add_mem' := by
  { intros f g hf hg Œ≥,
    rw [slash_k_add k Œ≥ f g, hf Œ≥, hg Œ≥], },
  smul_mem' := by
  { intros c f hf Œ≥,
    have : (c ‚Ä¢ f) ‚à£[k] Œ≥ = c ‚Ä¢ (f ‚à£[k] Œ≥ ) := by apply smul_slash_k,
    rw (hf Œ≥) at this,
    apply this, } }

/-- A function `f : ‚Ñç ‚Üí ‚ÑÇ` is weakly modular, of level `Œì` and weight `k ‚àà ‚Ñ§`, iff for every matrix
 `Œ≥ ‚àà Œì` we have `f(Œ≥ ‚Ä¢ z)= (c * z + d)^k f(z)` where `Œ≥= ![![a, b], ![c, d]]`, acting on `‚Ñç` via
 Moebius trainsformations. -/
@[simp]
lemma wmodular_mem' (k : ‚Ñ§) (Œì : subgroup SL(2, ‚Ñ§)) (f : ‚Ñç ‚Üí ‚ÑÇ) :
  f ‚àà (weakly_modular_submodule k Œì) ‚Üî
  ‚àÄ Œ≥ : Œì, ‚àÄ z : ‚Ñç, f (Œ≥ ‚Ä¢ z) = ((‚Üë‚ÇòŒ≥ 1 0 : ‚Ñù) * z + (‚Üë‚ÇòŒ≥ 1 1 : ‚Ñù)) ^ k * f z :=
begin
  dsimp only [weakly_modular_submodule], split,
  { intros h1 Œ≥ z,
    rw [‚Üê(by simp_rw h1 Œ≥ : (f ‚à£[k] Œ≥) z = f z), slash_k, mul_comm],
    have h55 := inv_mul_cancel (zpow_ne_zero k (upper_half_plane.denom_ne_zero Œ≥ z)),
    simp only [upper_half_plane.denom, upper_half_plane.subgroup_to_sl_moeb,
      upper_half_plane.sl_moeb, coe_coe, matrix.special_linear_group.coe_GL_pos_coe_GL_coe_matrix,
      matrix.special_linear_group.coe_matrix_coe, int.coe_cast_ring_hom, matrix.map_apply,
      of_real_int_cast] at *,
    rw [mul_assoc, h55, ‚Üêint.coe_cast_ring_hom, ‚Üêmatrix.special_linear_group.coe_matrix_coe,
      matrix.special_linear_group.det_coe ((Œ≥ : SL(2, ‚Ñ§) ) : SL(2, ‚Ñù))],
    simp only [of_real_one, one_zpow‚ÇÄ, mul_one] },
  { intros hf Œ≥,
    simp_rw slash_k,
    ext1,
    rw [‚Üêupper_half_plane.subgroup_moeb, (hf Œ≥ x), mul_comm],
    have h55 := inv_mul_cancel (zpow_ne_zero k (upper_half_plane.denom_ne_zero Œ≥ x)),
    simp_rw upper_half_plane.denom at *,
    simp only [matrix.special_linear_group.coe_GL_pos_coe_GL_coe_matrix, coe_coe,
      matrix.special_linear_group.coe_matrix_coe, int.coe_cast_ring_hom, matrix.map_apply,
      of_real_int_cast] at h55,
    simp only [coe_coe, matrix.special_linear_group.coe_GL_pos_coe_GL_coe_matrix,
      matrix.map_apply, of_real_int_cast],
    rw (matrix.special_linear_group.det_coe ((Œ≥ : SL(2, ‚Ñ§) ) : SL(2, ‚Ñù))),
    simp only [matrix.special_linear_group.coe_matrix_coe, int.coe_cast_ring_hom, matrix.map_apply,
      of_real_int_cast, of_real_one, one_zpow‚ÇÄ, mul_one],
    simp_rw [‚Üêmul_assoc, h55],
    simp },
end

lemma mul_modular {k_1 k_2 : ‚Ñ§} {Œì : subgroup SL(2, ‚Ñ§)} {f g : ‚Ñç ‚Üí ‚ÑÇ}
  (hf : f ‚àà weakly_modular_submodule k_1 Œì) (hg : g ‚àà weakly_modular_submodule k_2 Œì) :
  f * g ‚àà weakly_modular_submodule (k_1 + k_2) Œì :=
begin
  simp only [wmodular_mem', pi.mul_apply, coe_coe] at *,
  intros Œ≥ z,
  rw [(hf Œ≥ z), (hg Œ≥ z)],
  have pown := zpow_add‚ÇÄ (upper_half_plane.denom_ne_zero (Œ≥ : GL(2, ‚Ñù)‚Å∫) z) k_1 k_2,
  simp only [upper_half_plane.denom, coe_fn_coe_base, ne.def,
    matrix.general_linear_group.coe_fn_eq_coe, coe_coe] at pown,
  rw pown,
  ring,
end

/-! Conditions at cusps, defined using filters -/

def at_I_inf := filter.at_top.comap upper_half_plane.im

lemma at_I_inf_mem (S : set ‚Ñç) : S ‚àà at_I_inf ‚Üî (‚àÉ A : ‚Ñù, ‚àÄ z : ‚Ñç, A ‚â§ im z ‚Üí z ‚àà S) :=
begin
  simp only [at_I_inf, filter.mem_comap', filter.mem_at_top_sets, ge_iff_le, set.mem_set_of_eq,
    upper_half_plane.coe_im],
  split,
  { intro h, cases h with a h,
    exact ‚ü®a, (Œª z hz, by { apply h (im z) hz, refl })‚ü© },
  { intro h, cases h with A h,
    refine ‚ü®A, (Œª b hb x hx, by { apply (h x), rw hx, exact hb })‚ü© }
end

def is_bound_at_inf (f : ‚Ñç ‚Üí ‚ÑÇ) : Prop := asymptotics.is_O f (1 : ‚Ñç ‚Üí ‚ÑÇ) at_I_inf

def is_zero_at_inf (f : ‚Ñç ‚Üí ‚ÑÇ) : Prop := filter.tendsto f at_I_inf (ùìù 0)

lemma zero_form_is_zero_at_inf : is_zero_at_inf 0 := tendsto_const_nhds

lemma is_zero_at_inf_is_bound (f : ‚Ñç ‚Üí ‚ÑÇ) (hf : is_zero_at_inf f) : is_bound_at_inf f :=
begin
  apply asymptotics.is_O_of_div_tendsto_nhds, { simp, }, { convert hf, ext1, simp, }
end

lemma zero_form_is_bound : is_bound_at_inf 0 := is_zero_at_inf_is_bound _ zero_form_is_zero_at_inf

def zero_at_infty_submodule : submodule ‚ÑÇ (‚Ñç ‚Üí ‚ÑÇ) :=
{ carrier := is_zero_at_inf,
  zero_mem' := zero_form_is_zero_at_inf,
  add_mem' := by { intros a b ha hb, simpa using ha.add hb },
  smul_mem' := by { intros c f hf, simpa using hf.const_mul c }, }

def bounded_at_infty_submodule : submodule ‚ÑÇ (‚Ñç ‚Üí ‚ÑÇ) :=
{ carrier := is_bound_at_inf,
  zero_mem' := zero_form_is_bound,
  add_mem' := by { intros f g hf hg, simpa using hf.add hg, },
  smul_mem' := by { intros c f hf, simpa using hf.const_mul_left c }, }

lemma prod_of_bound_is_bound {f g : ‚Ñç ‚Üí ‚ÑÇ} (hf : is_bound_at_inf f) (hg : is_bound_at_inf g) :
  is_bound_at_inf (f * g) := by simpa using hf.mul hg

@[simp]lemma bound_mem (f : ‚Ñç ‚Üí ‚ÑÇ) :
  is_bound_at_inf f ‚Üî ‚àÉ (M A : ‚Ñù), ‚àÄ z : ‚Ñç, A ‚â§ im z ‚Üí abs (f z) ‚â§ M :=
begin
  simp_rw [is_bound_at_inf, asymptotics.is_O_iff, filter.eventually, at_I_inf_mem],
  simp,
end

/--The extension of a function from `‚Ñç` to `‚Ñç'`-/
def hol_extn (f : ‚Ñç ‚Üí ‚ÑÇ) : ‚Ñç' ‚Üí ‚ÑÇ := Œª (z : ‚Ñç'), (f (z : ‚Ñç))

instance : has_coe (‚Ñç ‚Üí ‚ÑÇ) (‚Ñç' ‚Üí ‚ÑÇ) := ‚ü®Œª f, hol_extn f ‚ü©

/-- A function `f : ‚Ñç ‚Üí ‚ÑÇ` is a modular form of level `Œì` and weight `k ‚àà ‚Ñ§` if it is holomorphic,
 weakly modular and bounded at infinity -/
structure is_modular_form_of_lvl_and_weight (Œì : subgroup SL(2,‚Ñ§)) (k : ‚Ñ§) (f : ‚Ñç ‚Üí ‚ÑÇ) : Prop :=
  (hol      : mdifferentiable ùìò(‚ÑÇ) ùìò(‚ÑÇ) (‚Üëf : ‚Ñç' ‚Üí ‚ÑÇ))
  (transf   : f ‚àà weakly_modular_submodule k Œì)
  (infinity : ‚àÄ (A : SL(2, ‚Ñ§)), is_bound_at_inf (f ‚à£[k] A))

/-- A function `f : ‚Ñç ‚Üí ‚ÑÇ` is a cusp form of level one and weight `k ‚àà ‚Ñ§` if it is holomorphic,
 weakly modular, and zero at infinity -/
structure is_cusp_form_of_lvl_and_weight (Œì : subgroup SL(2,‚Ñ§)) (k : ‚Ñ§) (f : ‚Ñç ‚Üí ‚ÑÇ) : Prop :=
  (hol      : mdifferentiable ùìò(‚ÑÇ) ùìò(‚ÑÇ) (Œª (z : ‚Ñç'), (f (z : ‚Ñç))))
  (transf   : f ‚àà weakly_modular_submodule k Œì)
  (infinity : ‚àÄ (A : SL(2, ‚Ñ§)), is_zero_at_inf (f ‚à£[k] A) )

/-- The zero modular form is a cusp form-/
lemma zero_cusp_form : is_cusp_form_of_lvl_and_weight Œì k 0 :=
{ hol := mdifferentiable_zero,
  transf := (weakly_modular_submodule k Œì).zero_mem',
  infinity := by
  { intro A,
    convert zero_form_is_zero_at_inf,
    rw slash_k, simp only [pi.zero_apply, zero_mul], refl, } }

lemma is_modular_form_of_lvl_and_weight_of_is_cusp_form_of_lvl_and_weight {Œì k f}
  (h : is_cusp_form_of_lvl_and_weight Œì k f) : is_modular_form_of_lvl_and_weight Œì k f :=
{ hol      := h.1,
  transf   := h.2,
  infinity := Œª A, is_zero_at_inf_is_bound _ (h.3 A) }

 /-- The zero modular form is a modular form-/
lemma zero_mod_form : is_modular_form_of_lvl_and_weight Œì k 0 :=
begin
  apply_rules [is_modular_form_of_lvl_and_weight_of_is_cusp_form_of_lvl_and_weight, zero_cusp_form],
end

/-- This is the space of modular forms of level `Œì` and weight `k`-/
def space_of_mod_forms_of_weight_and_level (Œì : subgroup SL(2, ‚Ñ§)) (k : ‚Ñ§) : submodule ‚ÑÇ (‚Ñç ‚Üí ‚ÑÇ) :=
{ carrier  := is_modular_form_of_lvl_and_weight Œì k,
  zero_mem':= zero_mod_form _ _,
  add_mem' := by
  { intros a b ha hb, split,
    exact mdifferentiable_add _ _ ha.hol hb.hol,
    exact (weakly_modular_submodule k Œì).add_mem' ha.transf hb.transf,
    intro, rw slash_k_add,
    exact bounded_at_infty_submodule.add_mem' (ha.infinity A) (hb.infinity A) },
  smul_mem' := by
  { intros c f hf,
    split,
    exact mdifferentiable_smul _ _ hf.hol,
    exact (weakly_modular_submodule k Œì).smul_mem' _ hf.transf,
    intro A, rw smul_slash_k, exact bounded_at_infty_submodule.smul_mem' _ (hf.infinity _), }, }

localized "notation `M(`k`, `Œì`)`:= space_of_mod_forms_of_weight_and_level Œì k" in modular_forms

/-- This is the space of cuspforms of level `Œì` and weigth `k`-/
def space_of_cusp_forms_of_weight_and_level (Œì : subgroup SL(2,‚Ñ§)) (k : ‚Ñ§): submodule ‚ÑÇ (‚Ñç ‚Üí ‚ÑÇ) :=
{ carrier   := is_cusp_form_of_lvl_and_weight Œì k,
  zero_mem' := zero_cusp_form _ _,
  add_mem'  := by
  { intros a b ha hb, split,
    exact mdifferentiable_add _ _ ha.hol hb.hol,
    exact (weakly_modular_submodule k Œì).add_mem' ha.transf hb.transf,
    intro A, rw slash_k_add,
    apply (zero_at_infty_submodule.add_mem' (ha.infinity A) (hb.infinity A)) },
  smul_mem' := by
  { intros c f hf, split,
    exact mdifferentiable_smul _ _ hf.hol,
    exact (weakly_modular_submodule k Œì).smul_mem' _ hf.transf,
    intro A, rw smul_slash_k, exact zero_at_infty_submodule.smul_mem' _ (hf.infinity _), }, }

localized "notation `S(`k`, `Œì`)`:= space_of_cusp_forms_of_weight_and_level Œì k" in modular_forms

lemma mul_modform {k_1 k_2 : ‚Ñ§} {Œì : subgroup SL(2, ‚Ñ§)} {f g : ‚Ñç ‚Üí ‚ÑÇ}
  (hf : f ‚àà M(k_1, Œì)) (hg : g ‚àà M(k_2, Œì)) : f * g ‚àà M(k_1 + k_2, Œì) :=
begin
  refine ‚ü®mdifferentiable_mul _ _ hf.1 hg.1, mul_modular hf.2 hg.2, _‚ü©,
  intro A, rw slash_k_mul_SL2 k_1 k_2 A f g,
  exact prod_of_bound_is_bound (hf.infinity A) (hg.infinity A),
end

/-! Constant functions are modular forms of weight 0 -/
section const_mod_form

def const_one_form : ‚Ñç ‚Üí ‚ÑÇ := 1

/-- The constant function is bounded at infinity -/
lemma const_one_form_is_bound : is_bound_at_inf const_one_form :=
  @asymptotics.is_O_const_const _ _ ‚ÑÇ _ _ 1 _ one_ne_zero _

/-- The constant function 1 is invariant under any subgroup of SL2Z -/
lemma const_one_form_is_invar (A : SL(2,‚Ñ§)) : const_one_form ‚à£[0] A = const_one_form :=
begin
  rw [slash_k, const_one_form], dsimp only,
  have : (((‚Üë‚Çò(A : GL(2,‚Ñù)‚Å∫)).det): ‚Ñù) = 1,
  { simp only [coe_coe,
      matrix.special_linear_group.coe_GL_pos_coe_GL_coe_matrix,
      matrix.special_linear_group.det_coe],},
  rw [zero_sub, this], simp, refl,
end

/-- The constant function 1 is modular of weight 0 -/
lemma const_mod_form : const_one_form ‚àà M(0, Œì) :=
{ hol      := by { simp_rw const_one_form, apply mdifferentiable_one, },
  transf   := by { intro Œ≥, apply const_one_form_is_invar, },
  infinity := by { intro A, rw const_one_form_is_invar A, exact const_one_form_is_bound,} }

end const_mod_form

end modular_forms
